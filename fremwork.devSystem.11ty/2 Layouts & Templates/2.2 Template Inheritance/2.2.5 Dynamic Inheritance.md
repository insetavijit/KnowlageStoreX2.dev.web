| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **2.2.5 Dynamic Inheritance** | Runtime Flexibility | Variable `extends`; theme switching; robust fallbacks | Change the parent on the fly. |
| **[[2.2.5.1 Variable Extends]]** | Syntax | `{% extends myVar %}`; passing layout paths in data | Parents don't have to be hardcoded. |
| **[[2.2.5.2 Theme Switching]]** | Use Case | Swapping base layouts based on environment or config; multi-brand sites | Same content, different frame. |
| **[[2.2.5.3 A/B Testing Layouts]]** | Strategy | Distributing layouts via data functions; testing structural changes | Structural testing, not just cosmetic. |
| **[[2.2.5.4 Computed Selection]]** | Logic | Using `eleventyComputed` to determine specific layout path | Calculate which shell to use. |
| **[[2.2.5.5 Safety Checks]]** | Robustness | Using `default()` filter for missing vars; preventing build errors | `extends layoutVar \| default('base.njk')` |

# 2.2.5 Dynamic Inheritance

Standard inheritance involves hardcoding the parent path (`{% extends "base.njk" %}`). **Dynamic Inheritance** unlocks the ability to determine the parent template *at compile time* using a variable (`{% extends myLayoutVariable %}`).

This transforms inheritance from a static tree into a malleable graph, allowing content to swap "shells" based on configuration, environment variables, or even randomness.

---

## 2.2.5.1 Variable Extends

Nunjucks allows the `extends` tag to accept a variable or an expression, not just a string literal.

**Static:**
```html
{% extends "layouts/base.njk" %}
```

**Dynamic:**
```html
{% extends layoutContext %}
```

In this scenario, `layoutContext` must be a variable available in the Data Cascade (front matter, global data, or computed data) that matches a valid file path in your `_includes` directory.

---

## 2.2.5.2 Theme Switching (The "Multi-Brand" Pattern)

The most common use case is **Theming**. Imagine you are generating a white-label documentation site that needs to look like "Brand A" for one build and "Brand B" for another.

**`_data/site.js`**:
```javascript
module.exports = {
  theme: "layouts/brand-a.njk" // or "layouts/brand-b.njk"
};
```

**`index.njk`**:
```html
{% extends site.theme %}

{% block content %}
  <h1>Welcome to our Documentation</h1>
{% endblock %}
```

By changing one global variable, every page on the site swaps its entire HTML structure—changing classes, DOM arrangement, and assets—while preserving the inner content blocks.

---

## 2.2.5.3 A/B Testing Layouts

Because Eleventy builds are static, "True" A/B testing usually happens client-side, but you can generate **structural variants** for testing.

You could assign a `layoutVariant` variable in your front matter or directory data file.

**`landing-page.njk`**:
```html
---
layoutVariant: "layouts/experimental-v2.njk"
---
{% extends layoutVariant %}
...
```

For more advanced setups, you can use a JavaScript Data File to randomly assign layouts during the build for internal testing or specific deployment branches.

---

## 2.2.5.4 Computed Selection

You can determine the parent template programmatically using **Computed Data**.

**`page.11tydata.js`**:
```javascript
module.exports = {
  eleventyComputed: {
    parentLayout: data => {
      // If it's a "draft" post, use the draft shell.
      if (data.draft) return "layouts/draft-shell.njk";
      
      // If it has a hero image, use the visual shell.
      if (data.heroImage) return "layouts/visual-shell.njk";
      
      // Default
      return "layouts/base.njk";
    }
  }
};
```

**`page.njk`**:
```html
{% extends parentLayout %}
```

This logic runs `before` the template renders, ensuring `parentLayout` holds the correct string path.

---

## 2.2.5.5 Safety Checks (Robustness)

Dynamic inheritance introduces a risk: **What if the variable is undefined?**

If `layoutContext` is empty, Nunjucks will throw an error: `template not found: undefined`.

To prevent this, valid strategies include:

1.  **The Default Filter**: Use the `default` filter inside the extends tag.
    ```html
    {% extends layoutContext | default("layouts/base.njk") %}
    ```

2.  **Global Defaults**: Ensure your global `_data` provides a fallback value so the variable is never truly undefined.

---

## Quick Reference

| Concept | Key Point |
| :--- | :--- |
| **Syntax** | `{% extends myVar %}` works just like a string path. |
| **Context** | The variable must be present in the Data Cascade. |
| **Fallbacks** | Always use `\| default('path.njk')` to prevent build crashes. |
| **Use Case** | Ideal for Theming, White-labeling, or Conditional Architecture. |
| **Limit** | You cannot change the parent *after* the template starts rendering; the variable must be ready upfront. |
