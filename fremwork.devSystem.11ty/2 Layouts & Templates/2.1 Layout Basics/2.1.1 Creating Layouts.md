Layouts in Eleventy are not merely wrappers for content; they are a **structural mechanism** that separates presentation from content, enabling reusable templates and consistent design across your static site. Understanding how layouts work transforms what might seem like template complexity into predictable, maintainable architecture.

---

## The Fundamental Principle: Separation of Concerns

At the heart of Eleventy's layout system, **layouts wrap content**, not the other way around. Your content files (Markdown, HTML, or other formats) focus purely on what they say. Layouts focus on how that content is presented. This separation is enforced through a simple but powerful mechanism: the `content` variable.

When Eleventy processes a template that specifies a layout, it renders the template's content first, then passes the rendered output to the layout as a variable called `content`. The layout can then place this content wherever it needs to appear within the larger HTML structure.

Think of layouts as **picture frames**. Your content is the artwork. The frame doesn't change the artwork itself; it provides context, borders, and presentation. You can swap frames without touching the artwork, and you can swap artwork without changing the frame.

This design immediately implies that **layouts are templates that consume other templates**. They exist in a special directory, receive processed content, and produce the final HTML that gets written to your output folder.

---

## The `_includes` Directory: Layout Storage

By default, Eleventy expects layouts to live in the `_includes` directory at the root of your input folder. This is not arbitrary—it's a deliberate design decision that prevents these files from being processed as standalone pages.

```
my-project/
├── _includes/
│   ├── base.njk
│   ├── post.njk
│   └── layouts/
│       └── article.njk
├── index.md
└── posts/
    └── my-post.md
```

Files in `_includes` are **never rendered directly** to your output folder. They exist solely to be consumed by other templates. This prevents your base HTML shell from appearing as `/base/index.html` in your site—a common gotcha for newcomers expecting different behavior.

The directory name can be customized in your configuration file, but `_includes` is conventional and immediately recognizable to anyone familiar with Eleventy. You can organize layouts into subdirectories within `_includes` for better structure:

```javascript
// eleventy.config.js
export default function(eleventyConfig) {
  return {
    dir: {
      includes: "_includes"  // This is the default
    }
  };
};
```

Subdirectories work naturally. A layout path like `layouts/base.njk` maps to `_includes/layouts/base.njk`. This organizational flexibility scales well as projects grow.

---

## Base Layout Structure: The HTML Foundation

A base layout typically contains the fundamental HTML document structure that every page needs: the `DOCTYPE`, `<html>` wrapper, `<head>` section, and `<body>` container. This is your **architectural foundation**.

```html
<!-- _includes/base.njk -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ title }}</title>
</head>
<body>
  {{ content | safe }}
</body>
</html>
```

The structure is deliberately minimal. Every page needs these elements, but nothing more should appear here unless it truly belongs on every single page. Navigation bars, footers, and other common elements often belong in intermediate layouts (we'll explore layout chaining shortly).

Notice the front matter can appear even in layouts:

```html
<!-- _includes/base.njk -->
---
siteName: "My Professional Site"
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>{{ title }} | {{ siteName }}</title>
</head>
<body>
  {{ content | safe }}
</body>
</html>
```

Layout front matter merges with content front matter in Eleventy's data cascade, with **content data taking precedence**. This enables default values in layouts that content can override.

---

## The `content` Variable: Injection Point

The `content` variable is where Eleventy injects your rendered template. When you write `{{ content }}` in a layout, you're marking the exact location where the processed child template will appear.

The syntax varies slightly by templating engine:

**Nunjucks (most common):**

```html
{{ content | safe }}
```

**Liquid:**

```html
{{ content }}
```

**JavaScript templates:**

```javascript
${data.content}
```

The `| safe` filter in Nunjucks is **critical** and often misunderstood. By default, Nunjucks escapes HTML to prevent XSS attacks. But your content is already rendered HTML that should be displayed as-is, not escaped. The `safe` filter tells Nunjucks: "This HTML is intentional, don't escape it."

Without `| safe`, your rendered Markdown would appear as literal text with visible HTML tags instead of formatted content:

```html
<!-- Without | safe -->
&lt;h1&gt;My Post Title&lt;/h1&gt;
&lt;p&gt;This is a paragraph.&lt;/p&gt;

<!-- With | safe -->
<h1>My Post Title</h1>
<p>This is a paragraph.</p>
```

Liquid doesn't require this filter because it handles HTML differently by default, but the principle remains: `content` contains pre-rendered HTML.

---

## Creating and Connecting Layouts

Connecting content to a layout happens through front matter. In your content file, specify which layout to use:

```markdown
---
layout: base.njk
title: "My First Post"
---

# Welcome

This is my content.
```

When Eleventy processes this file:

1. It renders the Markdown to HTML: `<h1>Welcome</h1><p>This is my content.</p>`
2. It looks for `_includes/base.njk` (the `.njk` extension is included)
3. It passes the rendered HTML as `content` to the layout
4. The layout renders with this content injected
5. The final HTML is written to the output directory

You can **omit the file extension** in the layout key:

```markdown
---
layout: base
---
```

When you do this, Eleventy searches for `base.*` with any supported template extension (`.njk`, `.liquid`, `.ejs`, etc.). While convenient, this has drawbacks:

- **Performance cost**: Eleventy must check multiple possible files
- **Ambiguity**: If both `base.njk` and `base.liquid` exist, behavior is undefined

For production projects, **always include the extension**. The clarity and performance benefit outweigh any typing convenience.

---

## Layout Resolution: How Eleventy Finds Layouts

Layout resolution follows a simple but precise algorithm:

1. **Check the layout key** in front matter: `layout: base.njk`
2. **Prepend the includes directory**: `_includes/base.njk`
3. **Resolve relative to the input directory**
4. **Load and process** the layout file

Subdirectories work naturally:

```markdown
---
layout: layouts/post.njk
---
```

This resolves to `_includes/layouts/post.njk`. The path is always relative to the includes directory, never to the current file.

A common misconception is that layouts are relative to the content file. They are not. All layout paths are resolved from `_includes`, regardless of where your content lives:

```
posts/
  2024/
    article.md  → layout: base.njk → _includes/base.njk
  2023/
    story.md    → layout: base.njk → _includes/base.njk
```

Both files reference the same layout, even though they're in different directories.

If a layout cannot be found, Eleventy throws a clear error:

```
Error: You're trying to use a layout that does not exist: base.njk (undefined)
```

This fail-fast behavior prevents silent failures where content renders without styling.

---

## Layout Chaining: Composition Through Nesting

Layouts can use other layouts. This **layout chaining** enables sophisticated template hierarchies where each layer adds specific functionality.

Consider a blog where all pages need the base HTML structure, but blog posts need additional post-specific elements:

```html
<!-- _includes/base.njk -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>{{ title }}</title>
</head>
<body>
  {{ content | safe }}
</body>
</html>
```

```html
<!-- _includes/post.njk -->
---
layout: base.njk
---
<article>
  <header>
    <h1>{{ title }}</h1>
    <time>{{ date }}</time>
  </header>
  <main>
    {{ content | safe }}
  </main>
</article>
```

```markdown
---
layout: post.njk
title: "Understanding Layouts"
date: 2024-01-15
---

This is my post content.
```

The processing flow works **inside-out**:

1. **Content renders first**: Markdown becomes `<p>This is my post content.</p>`
2. **First layout (post.njk) receives it**: Wraps it in `<article>` with header
3. **Second layout (base.njk) receives that**: Wraps everything in full HTML document

The final output:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Understanding Layouts</title>
</head>
<body>
  <article>
    <header>
      <h1>Understanding Layouts</h1>
      <time>2024-01-15</time>
    </header>
    <main>
      <p>This is my post content.</p>
    </main>
  </article>
</body>
</html>
```

This composition scales infinitely. You might have:

- `base.njk` → HTML foundation
- `page.njk` → Generic page wrapper (navigation, footer)
- `post.njk` → Blog post specific features
- `tutorial.njk` → Tutorial-specific features (table of contents, code blocks)

Each layer adds exactly what's needed for that type of content.

Data merges through the chain with **content data taking precedence**. If your post defines `title: "My Post"` and your layout defines `title: "Default"`, the post wins. This enables sensible defaults that content can override.

---

## Template Language Flexibility

A powerful but often overlooked feature: **layouts and content can use different template languages**. An EJS layout can wrap Nunjucks content. Liquid content can use a Nunjucks layout.

```markdown
<!-- markdown file (processed as Liquid by default) -->
---
layout: base.njk
---
{{ "Hello from Liquid" }}
```

```html
<!-- _includes/base.njk (Nunjucks) -->
<!DOCTYPE html>
<html lang="en">
<body>
  {{ content | safe }}
</body>
</html>
```

This works because Eleventy processes templates in stages:

1. **Template renders** in its native language
2. **Output (now HTML)** passes to layout
3. **Layout renders** in its native language

By the time content reaches the layout, it's already rendered HTML. The layout never sees the original template syntax.

This flexibility matters when migrating projects or working with teams that prefer different templating languages. You can gradually convert templates without rewriting everything at once.

---

## Layouts vs. Template Inheritance

Eleventy's layout system is **separate from** the template inheritance features built into Nunjucks (`{% extends %}`) or other templating languages. You can use both, but they serve different purposes.

**Eleventy layouts:**

- Language-agnostic (works across all template types)
- Configured in front matter
- Unidirectional (content → layout)
- Simpler mental model

**Nunjucks extends:**

- Nunjucks-specific
- Configured in template syntax
- Supports blocks that can be overridden
- More powerful but more complex

```html
<!-- Using Eleventy layouts -->
<!-- post.md -->
---
layout: base.njk
---
Content here

<!-- Using Nunjucks extends -->
<!-- post.njk -->
{% extends "base.njk" %}
{% block title %}My Title{% endblock %}
{% block content %}Content here{% endblock %}
```

For most projects, Eleventy layouts are sufficient and preferable. They're simpler, work across template languages, and integrate naturally with Eleventy's data cascade. Reserve `{% extends %}` for situations where you need the additional power of blocks and override points.

---

## Common Pitfalls and Solutions

**Problem: Layout not found**

```
Error: You're trying to use a layout that does not exist: base (undefined)
```

**Solutions:**

- Ensure the file exists in `_includes/`
- Include the file extension: `layout: base.njk` not `layout: base`
- Check for typos in the path
- Verify subdirectory structure matches

**Problem: Content appears as escaped HTML**

```html
<!-- Output -->
&lt;h1&gt;Title&lt;/h1&gt;
```

**Solution:** Add the `| safe` filter in Nunjucks layouts:

```html
{{ content | safe }}
```

**Problem: Variables not accessible in layout**

**Cause:** Front matter data might be misspelled or undefined

**Solution:** Remember data flows through the cascade. Content front matter is available in layouts:

```markdown
---
layout: base.njk
customValue: "Hello"
---
```

```html
<!-- _includes/base.njk -->
<body data-value="{{ customValue }}">
```

**Problem: Layout directory structure not respected**

**Solution:** Layout paths are always relative to `_includes`, not to the content file location. Use absolute paths from `_includes`:

```
layout: layouts/post.njk  ← Correct
layout: ../layouts/post.njk  ← Incorrect
```

---

## A Coherent System

When viewed as a complete system, Eleventy's layout architecture is **internally consistent**:

- Content focuses on what to say
- Layouts focus on how to present it
- The `content` variable is the injection point
- The `_includes` directory prevents direct rendering
- Layout resolution is predictable and explicit
- Chaining enables composition
- Template languages can mix freely
- Data flows through the cascade with clear precedence

In practical terms, layouts are neither decoration nor afterthought. They are **architectural decisions** about structure and reusability. Used deliberately, they enable maintainable sites where changing design means editing a handful of layouts, not hundreds of content files. Used carelessly, they create hidden dependencies and unclear data flow.

**The essence:** Layouts in Eleventy separate presentation from content while preserving flexibility, placing structural power in the hands of developers who design with intention and hierarchy.

The system trusts you to organize templates meaningfully. In return, it gives you the freedom to build sites that adapt, scale, and remain maintainable as they grow. This is not complexity—it's professional architecture with clear responsibilities.

---

## Quick Reference

| Concept                      | Key Point                                                                     |
| ---------------------------- | ----------------------------------------------------------------------------- |
| **Layouts**                  | Templates that wrap other content; defined in front matter                    |
| **`_includes` Directory**    | Default location for layouts; files here never render directly                |
| **Base Layout**              | Contains fundamental HTML structure (`DOCTYPE`, `<html>`, `<head>`, `<body>`) |
| **`content` Variable**       | Injection point where rendered child content appears                          |
| **`\| safe` Filter**         | Prevents HTML escaping in Nunjucks; use `{{ content \| safe }}`               |
| **Layout Resolution**        | Paths resolve from `_includes/`, not from current file location               |
| **File Extensions**          | Include them for clarity and performance: `base.njk` not `base`               |
| **Layout Chaining**          | Layouts can use other layouts via front matter `layout:` key                  |
| **Template Language Mixing** | Content and layouts can use different template engines                        |
| **Data Cascade**             | Front matter merges through chains; content data takes precedence             |

---

_This guide establishes the foundation for understanding Eleventy's layout system. Natural progressions include exploring **the data cascade in depth**, **advanced layout patterns**, and **performance optimization strategies**._