# Explicit Control: The Power of Front Matter

Front Matter Layout Assignment is the definitive mechanism for controlling the presentation of specific content in Eleventy. While directory data allows for broad, sweeping defaults, front matter assignment gives you explicit, surgical precision over individual templates. It is the override switch that ensures your architecture remains flexible enough to handle exceptions.

---

## The Mental Model: Directives vs. Defaults

To master layout assignment, you must understand the distinction between a **Default** and a **Directive**.

*   **Defaults (Directory Data)** are suggestions: "Everything in this folder usually looks like a blog post."
*   **Directives (Front Matter)** are commands: "This specific file uses the `splash` layout, period."

When you write `layout: ...` in a file's front matter, you are issuing a directive that bypasses the inheritance chain. Eleventy sees this key and stops looking for suggestions from the folder structure. This "Specific beats General" rule is the bedrock of maintainable configurationâ€”it allows you to define 90% of your site via broad rules and handle the 10% of exceptions directly in the files that need them.

---

## The Layout Key: Syntax and Resolution

The syntax is simple YAML. The `layout` key can live in the front matter of any template file (Markdown, HTML, Nunjucks, etc.).

```markdown
---
layout: post.njk
title: "My Article"
---
```

The value supports three distinct formats:

### 1. Relative Path (from `_includes`)
This is the most explicit form. It tells Eleventy exactly where to look within the includes directory.

```yaml
layout: layouts/blog/single.njk
```
*Resolves to*: `_includes/layouts/blog/single.njk`

### 2. Layout Alias
This uses a pre-configured short name mapped in your config file (see [[2.1.2 Layout Aliasing]]).

```yaml
layout: post
```
*Resolves to*: whatever `eleventyConfig.addLayoutAlias("post", ...)` points to.

### 3. Extensionless Filename (Not Recommended)
Eleventy can fuzzy-match files without extensions, but this is less performant and potentially ambiguous.

```yaml
layout: base    # Matches base.njk, base.liquid, base.ejs...
```

**Professional Tip**: Always use Aliases (for semantics) or Full Paths with Extensions (for clarity). Avoid extensionless paths in production.

---

## Overriding Defaults: The "Escape Hatch"

The primary use case for Front Matter assignment is the **Override**.

Imagine a standard blog structure:
*   `src/blog/blog.json` sets `layout: "post.njk"` for the whole folder.
*   You have 100 posts using this default.
*   You need to publish one "Interactive Feature" post that needs a completely different HTML structure (no sidebar, full-width canvas).

If you couldn't override, you'd have to move this file out of the `blog` folder, breaking your URL structure and organization.

With Front Matter overrides, you keep the file in place but change its frame:

**`src/blog/interactive-story.md`**
```markdown
---
layout: special-feature.njk  <-- This line wins
title: "The Big Interactive Story"
---
```

Eleventy sees the explicit key and ignores the directory data's `layout` property entirely.

---

## Disabling Layouts: The "Raw" Mode

Sometimes, the goal isn't to choose a *different* frame, but to have *no frame at all*. This is crucial for non-HTML output formats.

If you are building:
*   An XML Sitemap
*   A JSON API endpoint
*   A `manifest.json` file
*   An HTML partial for an HTMX request

You explicitly do **not** want your `base.njk` (with its `<html>` and `<body>` tags) wrapping this content.

To disable the layout, set it to `false`, `null`, or an empty string.

**`src/api/posts.json.njk`**
```json
---
layout: false
permalink: /api/posts.json
---
[
  {% for post in collections.post %}
    { "title": "{{ post.data.title }}", "url": "{{ post.url }}" }{% if not loop.last %},{% endif %}
  {% endfor %}
]
```

Without `layout: false`, this JSON content would be wrapped in `<!DOCTYPE html>...`, resulting in invalid JSON output.

---

## Conditional Layouts: Dynamic Logic

While Front Matter is declarative (static), you can make layout assignment dynamic by leveraging **Computed Data**. This allows the layout to be chosen based on logic at build time.

**Scenario**: You want all "Draft" posts to use a specific `draft-preview` layout with a visible warning banner, but standard posts to use the `post` layout.

**`src/blog/blog.11tydata.js`**
```javascript
module.exports = {
  eleventyComputed: {
    layout: data => {
      if (data.draft) {
        return "layouts/draft-preview.njk";
      }
      return "layouts/post.njk";
    }
  }
};
```

This effectively moves the decision logic from "Hardcoded in file" to "Calculated during build," granting you immense flexibility without manual file editing.

---

## Common Pitfalls

1.  **The "Layout Chain" Confusion**:
    Assigning a layout in front matter *starts* a chain. It does not replace the entire chain.
    *   File uses `layout: post.njk`.
    *   `post.njk` uses `layout: base.njk`.
    *   Result: `base(post(content))`.
    *   Users sometimes expect `layout: post.njk` to mean "Use ONLY post.njk and ignore base.njk". That is not how it works. To break the chain, `post.njk` itself would need to not refer to `base.njk`.

2.  **Path Typos**:
    `layout: layous/base.njk` (missing 't'). Eleventy will error out: "Layout not found".

3.  **Variable Collision**:
    If you try to use a data variable for a layout name (e.g., `layout: {{ myVar }}`), it won't work directly in standard YAML. You must use `eleventyComputed` or JS data files for variable-based assignment.

---

## A Coherent System

Front Matter Layout Assignment completes the "Layout Control Triad":

1.  **Global/Directory Data**: Sets the baseline defaults for large groups of content.
2.  **Layout Chaining**: Defines the vertical hierarchy of templates (A wraps B wraps C).
3.  **Front Matter Assignment**: Provides the horizontal control (File X uses Layout Y), initiating the chain and overriding defaults.

Together, these three mechanisms allow you to build complex, scalable sites where defaults save you time, but overrides give you control.

---

## Quick Reference

| Concept | Key Point |
| :--- | :--- |
| **Directive** | Front matter assignment is a command, not a suggestion. It overrides defaults. |
| **`layout: false`** | The standard way to output raw content (JSON, XML) without wrappers. |
| **Resolution** | Paths are relative to `_includes/`. Extensions are recommended (`.njk`). |
| **Aliases** | Short names defined in config can be used here (`layout: post`). |
| **Computed Layouts** | Use `eleventyComputed` to select layouts based on logic/data variables. |
| **Scope** | This key only applies to *this specific file*. |
