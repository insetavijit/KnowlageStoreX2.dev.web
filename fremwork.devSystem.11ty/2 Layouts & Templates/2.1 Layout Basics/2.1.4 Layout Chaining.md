# 2.1.4 Layout Chaining (Parent/Child)

Layout Chaining (often called "Parent/Child Layouts" or "Layout Stacking") is the architectural pattern of nesting one layout inside another. It is the mechanism that allows you to build a system of templates where specific layouts handle local concerns (like a blog post header with a date and author) while inheriting global concerns (like the HTML `Clean Boilerplate`, navigation, and footer) from a parent layout.

This concept turns layouts from simple wrappers into a **composable inheritance system**.

---

## The Onion Model: Visualizing Inheritance

To understand layout chaining, discard the idea of "pages" and think in terms of **wrapping layers**, like an onion or Matryoshka dolls.

In a flat system, every layout repeats the same HTML boilerplate (`<html>`, `<head>`, `<body>`). This violates the DRY (Don't Repeat Yourself) principle. If you want to add a Google Analytics script, you have to edit every single layout file.

In a chained system, you separate responsibilities into layers:

1.  **The Core (Content)**: Your Markdown file (`hello.md`). It knows nothing about HTML structure.
2.  **The Inner Layer (Context)**: The specific layout (`post.njk`). It wraps the content in an `<article>`, adds the Title (H1), Date, and Author Bio. It knows nothing about the `<html>` or `<head>` tags.
3.  **The Outer Layer (Shell)**: The global layout (`base.njk`). It wraps the inner layer. It owns the `<!DOCTYPE html>`, meta tags, script imports, global navigation, and footer.

When Eleventy processes this, it renders from the **inside out**:
1.  The **Content** renders.
2.  The **Specific Layout** receives the content, wraps it, and renders.
3.  The **Global Layout** receives the result of step 2, wraps it, and produces the final HTML.

---

## Implementation: The Chain Pattern

Implementation is surprisingly simple: a layout file can typically have its *own* configuration front matter, including a `layout` property.

### 1. The Global Shell (`_includes/base.njk`)

This is the "root" layout. It has no parents. Its job is to define the document boundaries.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ title }}</title>
  <link rel="stylesheet" href="/style.css">
</head>
<body>
  <header>
    <nav>
      <a href="/">Home</a>
      <a href="/about/">About</a>
    </nav>
  </header>

  <main>
    {{ content | safe }} <!-- Child content is injected here -->
  </main>

  <footer>
    <p>&copy; 2024 My Website</p>
  </footer>
</body>
</html>
```

### 2. The Specific Wrapper (`_includes/post.njk`)

This layout handles the presentation logic specific to **blog posts**. Notice the front matter at the top: it declares `layout: base.njk`.

```html
---
layout: base.njk
---
<article class="blog-post">
  <header class="post-header">
    <h1>{{ title }}</h1>
    <div class="post-meta">
      <time datetime="{{ date | dateIso }}">{{ date }}</time>
      <span class="author">By {{ author }}</span>
    </div>
  </header>

  <div class="post-content">
    {{ content | safe }} <!-- The Markdown content is injected here -->
  </div>

  <section class="bio-box">
    <h3>About the Author</h3>
    <p>This post was written by {{ author }}.</p>
  </section>
</article>
```

### 3. The Content Source (`posts/my-story.md`)

The content file only needs to know about its immediate parent (`post.njk`). It doesn't need to know that `base.njk` exists.

```markdown
---
layout: post.njk
title: "My First Story"
date: 2024-01-01
author: "Alice"
---

This is the actual text of the story. I don't need to worry about the header, footer, or even the article title.
```

---

## Data Bubbling: The Data Cascade in Chains

One of the most powerful aspects of layout chaining is how **Data Cascades** up the chain.

When `base.njk` renders, it has access to **all the data** from the layers below it.

*   `posts/my-story.md` defines `title`.
*   `post.njk` doesn't define a title, but it uses `{{ title }}`.
*   `base.njk` uses `{{ title }}` in the `<title>` tag.

Because of the Cascade, the Title defined in the Markdown file is available to the Grandparent (`base.njk`).

### Overriding Upwards

What if `post.njk` wants to define a specific class for the `<body>` tag, which lives in `base.njk`?

**In `post.njk`:**
```html
---
layout: base.njk
bodyClass: "single-post-template"
---
...
```

**In `base.njk`:**
```html
<body class="{{ bodyClass }}">
```

The specific layout inserts data into the cascade that the parent layout can consume. This allows child layouts to "configure" their parents.

---

## Use Cases: When to Chain?

You should consider chaining whenever you find yourself copying and pasting HTML structure.

### Scenario A: The Documentation Site

*   **`base.njk`**: HTML Shell, Scripts, Meta Tags.
*   **`home.njk`** (extends `base`): Full-width marketing header, grid of features.
*   **`doc-page.njk`** (extends `base`): Sidebar navigation (left), Article content (center), Table of Contents (right).

### Scenario B: The Dark Mode Section

*   **`base.njk`**: Standard shell.
*   **`dark-theme.njk`** (extends `base`): Sets a `theme-dark` class on a wrapper and perhaps injects a specific dark-mode CSS file.
*   **`gallery.njk`** (extends `dark-theme`): A photo gallery layout that wants that dark background.

### Scenario C: RSS Feeds and Sitemaps

Interestingly, chaining isn't just for HTML. You can chain XML layouts too, though it's less common. Usually, a feed or sitemap uses a single layout since the structure is rigid.

---

## Common Pitfalls

1.  **Infinite Loops**: Do not make `layout-a.njk` use `layout-b.njk` if `layout-b.njk` uses `layout-a.njk`. Eleventy will detect this loop and throw an error.
2.  **`intro` vs `content`**: In Nunjucks *Blocks* (inheritance via `{% extends %}`), you define blocks. In Eleventy *Layouts*, you mainly just have `content`. If you need to inject content into multiple distinct areas of a parent layout (e.g., a Sidebar AND a Main Area), standard Layout Chaining might act as a constraint. In those complex cases, standard Nunjucks `{% extends %}` might be more appropriate, or you can use "Computed Data" or "Render Plugin" to capture distinct chunks of content.
3.  **Double Escaping**: Remember to use `| safe` in **every link of the chain**. Use it in `post.njk` outputting the markdown, AND in `base.njk` outputting the `post.njk` result. If you miss one, you'll see escaped HTML code on your screen.

---

## Summary Definitions

| Subtopic | Focus & Purpose | Key Concepts / Details | One-Line Recall |
| :--- | :--- | :--- | :--- |
| **2.1.4 Layout Chaining** | Modular Inheritance | Nesting layouts; `content` injection sequence; separation of concerns (Global vs Local) | Layouts consuming other layouts (Inception). |
| **The Onion Model** | Mental Model | Inside-out rendering; Content -> Specific Layout -> Generic Layout | Visualize wrapping layers around content. |
| **Implementation** | Coding Pattern | Adding `layout:` front matter to a `.njk` file; `{{ content }}` passing; `layout: base.njk` inside `post.njk` | A layout file can have its own layout. |
| **Data Bubbling** | Data Flow | Variable availability up the chain; Child overrides Parent precedence; sharing Front Matter | Content data wins over layout data. |
| **Use Cases** | Strategy | DRY principles; single source of truth for HTML shell; thematic variations (Docs vs Blog) | Write the `<head>` only once. |
