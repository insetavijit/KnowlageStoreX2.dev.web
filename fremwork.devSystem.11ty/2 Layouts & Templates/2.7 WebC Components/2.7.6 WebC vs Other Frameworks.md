| **Subtopic** | **Focus & Purpose** | **Key Concepts / Details** | **One-Line Recall** |
| :--- | :--- | :--- | :--- |
| **2.7.6 WebC vs Other Frameworks** | Comparison | React, Vue, Svelte, Nunjucks, Astro | Why choose WebC? |
| **[[2.7.6.1 Vs React/Vue]]** | Runtime | React sends JS to browser (Hydration); WebC sends HTML | 0kb Client JS. |
| **[[2.7.6.2 Vs Astro]]** | Architecture | Both are "Islands" architectures; WebC is Eleventy-native | Astro for Eleventy. |
| **[[2.7.6.3 Vs Nunjucks Macros]]** | Ergonomics | WebC uses HTML syntax (`<card>`) vs Function syntax (`{{ card() }}`) | HTML syntax wins. |
| **[[2.7.6.4 Vs Native WC]]** | Platform | WebC is a *compiler* for Native Web Components; can output both | Compilation step. |
| **[[2.7.6.5 When to use which]]** | Strategy | Use WebC for Content Sites; React for dashboards/apps | Right tool for job. |

# 2.7.6 WebC vs Other Frameworks

If you are coming from the React/Next.js world, WebC might look familiar yet feel "missing" something. That "missing" thing is client-side JavaScript.

---

## 2.7.6.1 Vs React / Vue (The Cost of Hydration)

**React**:
1.  Server renders HTML.
2.  Browser downloads HTML.
3.  Browser downloads React bundle (100kb+).
4.  Browser executes JS to "Hydrate" the DOM (make it interactive).

**WebC**:
1.  Server renders HTML.
2.  Browser downloads HTML.
3.  **Done.**

If you add a script tag to a WebC component, the browser only downloads *that specific script*. There is no "Runtime Library" to download. This makes WebC sites significantly faster on mobile devices.

---

## 2.7.6.2 Vs Astro

WebC and Astro share almost the exact same philosophy: **Server-First Component Islands**.

*   **Astro**: Allows you to use React/Vue/Svelte components and compiles them to HTML.
*   **WebC**: Is a dedicated syntax just for this purpose.

If you are already using Eleventy, WebC is the obvious choice because it integrates deeply with the Eleventy Data Cascade (Front Matter, Collections), which Astro handles differently.

---

## 2.7.6.3 Vs Nunjucks Macros

Before WebC, the only way to make reusable components in Eleventy was Nunjucks Macros.

**Macro**:
```html
{{ card(title="Hello", icon="star") }}
```

**WebC**:
```html
<my-card title="Hello" icon="star"></my-card>
```

**Why WebC wins**:
1.  **Scoped CSS**: Macros have no mechanism to scope styles. WebC does.
2.  **Syntax**: HTML attributes are more readable than function arguments for UI work.
3.  **Slotting**: Passing complex HTML content into a Macro argument is painful. Passing it into a WebC `<slot>` is native.

---

## 2.7.6.4 Vs Native Web Components

Web Components (Custom Elements) are a browser standard (`customElements.define`).

WebC is a **Compiler** for that standard.
*   You can write a WebC component that compiles to a simple `<div>` (Ghost component).
*   You can write a WebC component that compiles to a `<my-card>` that hydrates with a native script.

WebC removes the boilerplate of writing repetitive `HTMLElement` classes for simple display components.

---

## 2.7.6.5 When to use what?

**Use WebC if**:
*   You are building a Content Site (Blog, Portfolio, Marketing, Documentation).
*   Your interactivity is sparse (Mobile menu, Carousel, Dark Mode toggle).

**Use React/Vue if**:
*   You are building a Dashboard or SaaS App.
*   You need complex state management (Redux/Zustand) across many views.
*   The site feels more like an "App" than a "Document".

---

## Quick Reference

| Feature | React | Nunjucks Macro | WebC |
| :--- | :--- | :--- | :--- |
| **Output** | JS + HTML | HTML | HTML |
| **Syntax** | JSX | Function | HTML |
| **CSS Scope** | CSS-in-JS | Manual | Automatic |
| **Client JS** | Heavy | Zero | Zero (or opt-in) |
| **Best For** | Apps | Simple snippets | UI Components |
