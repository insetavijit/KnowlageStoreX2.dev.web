| Topic | Focus & Purpose |
| --- | --- |
| **[[2.8.1 Class-based Templates]]** | OOP structure: creating a `.11ty.js` file that exports a class; the `render(data)` method for output; the `data()` method for front matter defaults; accessing `this` context; class inheritance for shared logic. Object-oriented templates. |
| **[[2.8.2 Functional Templates]]** | Functional approach: simple function exports (`module.exports = function(data) {}`); returning template literal strings; arrow function syntax; when to use functions vs classes; stateless rendering. Simpler alternative. |
| **[[2.8.3 Template Literals]]** | Native templating: using ES6 backticks for multi-line strings; interpolation with `${expression}`; embedding conditionals with ternary operators; mapping arrays; tagged template literals for advanced use cases. String composition. |
| **[[2.8.4 Markdown in JS]]** | Mixing formats: processing Markdown strings inside JS templates; using `eleventyConfig.addPlugin(renderPlugin)`; the `renderTemplate` paired shortcode; rendering Markdown from data; hybrid content strategies. Format integration. |
| **[[2.8.5 Async Rendering]]** | Async power: `async render(data)` functions; awaiting database queries, API calls, or file reads directly in templates; error handling with try/catch; Promise.all for parallel fetches; build-time data fetching. Dynamic data. |
| **[[2.8.6 JS Template Use Cases]]** | When to choose JS: complex logic requirements; programmatic HTML generation; integration with npm packages; generating non-HTML content (JSON, XML, RSS); performance considerations vs other template languages. Decision framework. |
