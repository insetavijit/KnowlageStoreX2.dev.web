# Dependent Variables: Chained Computation

Computed data can reference **other computed data**. This creates a chain of calculations where each step builds on the previous one. Eleventy resolves dependencies automatically, but you need to understand the resolution order.

---

## The Fundamental Principle: Resolution Order Matters

Eleventy attempts to resolve dependencies in a sensible order. If `A` depends on `B`, it will compute `B` first.

```javascript
eleventyComputed: {
  firstName: "John",
  lastName: "Doe",
  fullName: (data) => `${data.firstName} ${data.lastName}`
}
```

`fullName` depends on `firstName` and `lastName`. Eleventy resolves them first.

---

## Self-Reference (Append/Modify)

A computed value can reference **its own original value** to modify it:

```yaml
---
title: "My Post"
eleventyComputed:
  title: "{{ title }} | My Site"
---
```

This takes the original `title` ("My Post") and transforms it ("My Post | My Site").

---

## Multi-Step Chains

```javascript
eleventyComputed: {
  rawTitle: (data) => data.title || "Untitled",
  cleanTitle: (data) => data.rawTitle.trim(),
  slug: (data) => data.cleanTitle.toLowerCase().replace(/\s+/g, '-'),
  permalink: (data) => `/blog/${data.slug}/`
}
```

Resolution order:
1. `rawTitle` (depends on `title`)
2. `cleanTitle` (depends on `rawTitle`)
3. `slug` (depends on `cleanTitle`)
4. `permalink` (depends on `slug`)

---

## Fallback Chains

Use dependencies to create robust fallback logic:

```javascript
eleventyComputed: {
  metaTitle: (data) => data.seoTitle || data.title || "Default Title",
  metaDescription: (data) => data.description || data.excerpt || `Read about ${data.metaTitle}`
}
```

`metaDescription` uses `metaTitle`, which is itself computed.

---

## Accessing Collections (Advanced)

You can reference collections in computed data:

```javascript
eleventyComputed: {
  relatedPosts: (data) => {
    return data.collections.post
      .filter(p => p.data.category === data.category && p.url !== data.page.url)
      .slice(0, 3);
  }
}
```

Be careful with performance—this runs for every file.

---

## Common Pitfalls and Solutions

**Problem:** Circular dependency error.

**Cause:** A → B → C → A creates an infinite loop.

**Solution:** Redesign so dependencies flow one direction only.

---

**Problem:** Variable is undefined in chain.

**Cause:** The source variable hasn't been computed yet or doesn't exist.

**Solution:** Check the order and ensure the base variable is defined.

---

**Problem:** Deep chains are hard to debug.

**Solution:** Keep chains shallow (2-3 levels max). Use `console.log` inside computed functions to trace values.

---

## Quick Reference

| Pattern | Example |
| :--- | :--- |
| **Self-modify** | `title: "{{ title }} - suffix"` |
| **Fallback** | `data.a \|\| data.b \|\| "default"` |
| **Chain** | A → B → C in sequence |
| **Access Collections** | `data.collections.post` |

---

_This guide covers dependent variables. Natural progressions include **computed permalinks** and **avoiding circular dependencies**._
