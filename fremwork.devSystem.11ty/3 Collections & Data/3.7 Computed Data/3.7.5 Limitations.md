# Computed Data Limitations: Boundaries and Pitfalls

`eleventyComputed` is powerful but has constraints. Understanding these boundaries prevents frustrating debugging sessions and helps you design better data architectures.

---

## The Fundamental Principle: Power Comes With Responsibility

Computed data runs **for every file** at **the end of the cascade**. This creates opportunities for complexity that can slow builds and make data flow hard to trace.

---

## Limitation 1: Circular Dependencies

The most common error:

```javascript
eleventyComputed: {
  a: (data) => data.b + 1,
  b: (data) => data.a + 1  // Circular!
}
```

Result: Build error or infinite loop.

**Solution:** Dependencies must be acyclic. Draw a diagram if needed.

---

## Limitation 2: Performance Impact

Computed data runs for every content file:
- 1,000 files = 1,000 executions
- Heavy computations multiply

**Bad:**
```javascript
eleventyComputed: {
  allRelated: (data) => {
    // Filtering 10,000 items for every file
    return data.collections.all.filter(p => 
      p.data.category === data.category
    );
  }
}
```

**Better:** Pre-compute in `addCollection` once, not per-file.

---

## Limitation 3: Access Timing

Some plugin features require data to be ready **before** computed data runs. If a plugin caches data early, computed modifications won't be seen.

**Symptom:** Computed value works in template but not in plugin.

**Solution:** Check plugin documentation for cascade interaction.

---

## Limitation 4: Debugging Difficulty

With multiple cascade layers plus computed data, tracing a value's origin becomes complex:

```
Global Data ← Directory Data ← Layout ← Front Matter ← Computed
```

Any of these could set or modify a variable.

**Solution:** Use `console.log` in computed functions:
```javascript
fullTitle: (data) => {
  console.log(`[${data.page.inputPath}] title = ${data.title}`);
  return `${data.title} | Site`;
}
```

---

## Limitation 5: No Access to Future Data

Computed data can't access data that will be computed later in the same object:

```javascript
eleventyComputed: {
  b: (data) => data.a, // Works if 'a' exists elsewhere
  a: () => "value"     // But 'a' inside eleventyComputed might not be ready
}
```

Eleventy tries to resolve order, but complex inter-dependencies can fail.

---

## Limitation 6: Template Engine Restrictions

Template strings in computed data use a limited context. Some advanced template features may not work identically to regular templates.

---

## Limitation 7: Overuse Complexity

It's tempting to compute everything. But:
- 50 computed properties = hard to understand
- Chained dependencies = unpredictable order
- Side effects = hidden logic

**Principle:** Use computed data for values that genuinely need late binding. Use regular front matter for simple values.

---

## Best Practices

1. **Keep it simple**: 3-5 computed properties per file type max
2. **Avoid side effects**: Computed functions should be pure
3. **Log during debug**: `console.log` is your friend
4. **Document dependencies**: Comment what depends on what
5. **Prefer collections**: For cross-file relationships, use `addCollection`

---

## Quick Reference

| Limitation | Mitigation |
| :--- | :--- |
| **Circular deps** | Draw dependency graph |
| **Performance** | Move to `addCollection` |
| **Plugin timing** | Check plugin docs |
| **Debugging** | Use `console.log` |
| **Complexity** | Limit computed properties |

---

_This guide covers computed data limitations. You've now completed the computed data section of the Eleventy syllabus._
