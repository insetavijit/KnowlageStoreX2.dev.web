# Fetching External Data: Connecting to APIs

The true power of JavaScript data files emerges when you fetch data from external sourcesâ€”headless CMSs, APIs, databases. Your static site becomes a **snapshot of dynamic data** at build time.

---

## The Fundamental Principle: Build-Time Hydration

When you fetch data during the build, you're creating a static copy of dynamic content. The API is called once, the data is captured, and your site becomes self-contained.

This is the JAMstack philosophy: **decouple data sources from delivery**.

---

## Async Data Files

To fetch data, export an async function:

```javascript
// _data/posts.js
module.exports = async function() {
  const response = await fetch('https://api.example.com/posts');
  const data = await response.json();
  return data;
};
```

Eleventy waits for the Promise to resolve before continuing the build.

---

## Using Native Fetch (Node 18+)

Node.js 18+ includes native `fetch`:

```javascript
module.exports = async function() {
  const res = await fetch('https://api.github.com/users/octocat/repos');
  return await res.json();
};
```

For older Node versions, install `node-fetch` or `axios`.

---

## Error Handling

API calls can fail. Always handle errors gracefully:

```javascript
module.exports = async function() {
  try {
    const response = await fetch('https://api.example.com/data');
    
    if (!response.ok) {
      console.warn(`API returned ${response.status}`);
      return []; // Return empty array as fallback
    }
    
    return await response.json();
  } catch (error) {
    console.error('Failed to fetch data:', error.message);
    return []; // Fallback data
  }
};
```

This prevents a single API failure from crashing your entire build.

---

## Authentication

Many APIs require authentication:

```javascript
module.exports = async function() {
  const response = await fetch('https://api.cms.com/content', {
    headers: {
      'Authorization': `Bearer ${process.env.CMS_API_KEY}`,
      'Content-Type': 'application/json'
    }
  });
  
  return await response.json();
};
```

**Never** hardcode API keys. Use environment variables.

---

## Pagination (Multiple Requests)

Some APIs paginate results:

```javascript
module.exports = async function() {
  let allPosts = [];
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const response = await fetch(`https://api.example.com/posts?page=${page}`);
    const data = await response.json();
    
    allPosts = allPosts.concat(data.items);
    hasMore = data.hasNextPage;
    page++;
  }
  
  return allPosts;
};
```

---

## Rate Limiting Awareness

APIs often have rate limits. During development, you might rebuild frequently and hit limits.

**Solutions:**
1. Use caching (see below)
2. Mock data in development
3. Use `@11ty/eleventy-fetch` for intelligent caching

---

## Caching with eleventy-fetch

The official Eleventy Fetch plugin caches responses locally:

```javascript
const EleventyFetch = require("@11ty/eleventy-fetch");

module.exports = async function() {
  const url = "https://api.example.com/posts";
  
  const data = await EleventyFetch(url, {
    duration: "1d", // Cache for 1 day
    type: "json"
  });
  
  return data;
};
```

This dramatically speeds up local development and respects API rate limits.

---

## Common Pitfalls and Solutions

**Problem:** Build takes too long waiting for API.

**Solution:** Use `@11ty/eleventy-fetch` with caching enabled.

---

**Problem:** Build fails when API is down.

**Solution:** Add try/catch with fallback data. Return cached or empty data.

---

**Problem:** API returns too much data.

**Solution:** Filter/transform the data before returning (see Data Preprocessing).

---

## Quick Reference

| Technique | Purpose |
| :--- | :--- |
| **Async Export** | `module.exports = async () => {}` |
| **Native Fetch** | Built into Node 18+ |
| **Error Handling** | Try/catch with fallback data |
| **Caching** | `@11ty/eleventy-fetch` |
| **Authentication** | Headers with `process.env.API_KEY` |

---

_This guide covers external data fetching. Natural progressions include **data preprocessing**, **caching strategies**, and **incremental builds**._
