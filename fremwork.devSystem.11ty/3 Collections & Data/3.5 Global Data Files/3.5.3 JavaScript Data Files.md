# JavaScript Data Files: Dynamic Data at Build Time

JavaScript data files unlock the full power of Node.js inside your `_data` directory. They execute during the build, allowing you to compute values, access environment variables, and generate dynamic data structures.

---

## The Fundamental Principle: Code That Runs Once

Unlike JSON/YAML which are parsed, JavaScript files are **executed**. The value you export becomes the data. This runs once at build time, not per-page.

```javascript
// _data/buildInfo.js
module.exports = {
  buildTime: new Date().toISOString(),
  nodeVersion: process.version
};
```

Now `{{ buildInfo.buildTime }}` shows exactly when the site was built.

---

## Export Patterns

**Object Export (Simple):**
```javascript
module.exports = {
  siteName: "My Blog",
  year: new Date().getFullYear()
};
```

**Function Export (More Control):**
```javascript
module.exports = function() {
  return {
    environment: process.env.ELEVENTY_ENV || "development",
    isProduction: process.env.NODE_ENV === "production"
  };
};
```

The function is called once, and its return value becomes the data.

---

## Environment Variables

One of the most important uses is accessing environment variables securely:

```javascript
// _data/env.js
module.exports = {
  apiKey: process.env.API_KEY,
  analyticsId: process.env.ANALYTICS_ID,
  isProduction: process.env.NODE_ENV === "production"
};
```

**Critical:** Never commit secrets to your repository. Use `.env` files locally and hosting provider secrets in production.

**Template Usage:**
```html
{% if env.isProduction %}
  <script src="/analytics.js" data-id="{{ env.analyticsId }}"></script>
{% endif %}
```

---

## Computed Values

Generate data that would be tedious to maintain manually:

```javascript
// _data/dates.js
const months = [
  "January", "February", "March", "April",
  "May", "June", "July", "August",
  "September", "October", "November", "December"
];

module.exports = {
  currentYear: new Date().getFullYear(),
  currentMonth: months[new Date().getMonth()],
  months: months
};
```

---

## CommonJS vs ESM

**CommonJS (Traditional):**
```javascript
// _data/example.js or _data/example.cjs
module.exports = { key: "value" };
```

**ES Modules:**
```javascript
// _data/example.mjs
export default { key: "value" };
```

Eleventy 2.0+ supports both. Use `.cjs` or `.mjs` extensions to be explicit.

---

## Accessing Other Data

JavaScript data files can read other files:

```javascript
// _data/processed.js
const fs = require('fs');
const path = require('path');

module.exports = function() {
  const raw = JSON.parse(
    fs.readFileSync(path.join(__dirname, 'raw.json'), 'utf8')
  );
  
  // Process the data
  return raw.map(item => ({
    ...item,
    slug: item.title.toLowerCase().replace(/\s+/g, '-')
  }));
};
```

---

## Common Pitfalls and Solutions

**Problem:** Data file changes don't appear after rebuild.

**Cause:** Node.js caches `require()` results.

**Solution:** Restart the Eleventy dev server, or use a function export.

---

**Problem:** Environment variable is `undefined`.

**Cause:** Variable not set in the current environment.

**Solution:** Provide a default: `process.env.VAR || "default"`.

---

**Problem:** "Cannot use import statement" error.

**Cause:** Using ESM syntax in a `.js` file without ESM configured.

**Solution:** Use `.mjs` extension or set `"type": "module"` in `package.json`.

---

## Quick Reference

| Export Type | Syntax | Use Case |
| :--- | :--- | :--- |
| **Object** | `module.exports = {}` | Simple static data |
| **Function** | `module.exports = () => {}` | Computed at build time |
| **Async** | `module.exports = async () => {}` | External API calls |

---

_This guide covers JavaScript data files. Natural progressions include **fetching external data**, **caching strategies**, and **async data patterns**._
