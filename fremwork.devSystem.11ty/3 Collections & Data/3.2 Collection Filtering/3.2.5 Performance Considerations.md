# Eleventy Collection Performance: A Professional Mental Model

Collection filtering is deceptively simple in demo projects but becomes a **critical performance bottleneck** as sites scale into thousands of pages. Understanding how Eleventy executes collection logic transforms what might seem like trivial JavaScript into deliberate, optimized architecture.

---

## The Fundamental Principle: Build-Time Computation

Unlike dynamic server-side frameworks where database queries happen per-request, Eleventy runs **everything once** during a build. This is both a blessing and a curse:

- **Blessing**: You can do complex computations without worrying about runtime latency.
- **Curse**: Inefficient code multiplies. If your collection filter takes 10ms per item, and you have 5,000 items, that's 50 seconds of build time—just for filtering.

Think of your build process as a **factory assembly line**. Each inefficiency compounds. A 1-second delay that happens 1,000 times costs you 16 minutes. The goal is to make each step as lean as possible.

---

## The Cost of `.getAll().filter()`

The most common (and naive) collection pattern is:

```javascript
eleventyConfig.addCollection("myCollection", collection => {
  return collection.getAll().filter(item => {
    // Some condition
    return item.data.published === true;
  });
});
```

This seems harmless, but let's trace what happens:

1. **`getAll()` retrieves every item**: Every file in your project that produces an output.
2. **`.filter()` iterates over every item**: Even if you only care about the 50 items in `/posts/`.
3. **The callback runs N times**: N = total number of files.

For a 10,000-page site with 6 custom collections, you're running 60,000 filter callbacks. If each callback does anything non-trivial (string parsing, date calculations, array lookups), the cost explodes.

---

## Use Specialized Methods First

Eleventy provides optimized helpers that avoid iterating through everything:

| Method | What It Does | Performance |
| :--- | :--- | :--- |
| `getAll()` | Returns every item | **Slowest** |
| `getFilteredByTag("post")` | Returns items with that tag | **Fast** |
| `getFilteredByGlob("src/posts/*.md")` | Returns items matching a file path pattern | **Fastest** |
| `getFilteredByTags(["A", "B"])` | Returns items with *all* listed tags | **Medium** |

**Optimized Pattern:**

```javascript
// SLOW: Iterates over everything
collection.getAll().filter(item => item.data.tags?.includes("post"));

// FAST: Uses internal indexing
collection.getFilteredByTag("post");
```

Eleventy internally maintains indexes for tags and file paths. Using the dedicated methods leverages these indexes instead of re-scanning the entire collection.

---

## Filter Early, Transform Late

The order of chained methods matters critically.

**Bad (Slow):**

```javascript
collection.getAll()
  .map(item => {
    // Expensive transformation
    return { ...item, computed: heavyFunction(item) };
  })
  .filter(item => item.data.featured);
```

This runs `heavyFunction` on **every** item, even the 95% that aren't featured.

**Good (Fast):**

```javascript
collection.getAll()
  .filter(item => item.data.featured)  // Reduce the set FIRST
  .map(item => {
    // Only runs on the featured items
    return { ...item, computed: heavyFunction(item) };
  });
```

By filtering first, you apply the expensive transformation only to the relevant subset.

**The Principle:** Reduce the array size as early as possible. Every item you eliminate saves computation in all subsequent steps.

---

## Avoid I/O Inside Loops

A catastrophic anti-pattern is reading files inside the filter callback:

```javascript
// TERRIBLE: Reads file from disk N times
collection.getAll().filter(item => {
  const fileContent = fs.readFileSync(item.inputPath, "utf8");
  return fileContent.includes("DRAFT");
});
```

For 5,000 items, this performs 5,000 synchronous file reads **during the build**, grinding everything to a halt.

**Solution 1: Use Front Matter**

Store the data you need in front matter, which Eleventy has already parsed:

```yaml
---
draft: true
---
```

```javascript
collection.getAll().filter(item => !item.data.draft);
```

**Solution 2: Pre-Compute in Data Files**

Use global data files or JavaScript data templates to pre-compute expensive lookups once, then reference them in filters.

---

## The Memoization Principle

`addCollection` callbacks run **once per build**. But if you're calling helper functions inside them, ensure those helpers don't re-compute on every call.

**Inefficient:**

```javascript
function getSiteConfig() {
  return JSON.parse(fs.readFileSync("./site.json", "utf8")); // Reads file EVERY time
}

eleventyConfig.addCollection("posts", collection => {
  const config = getSiteConfig();
  return collection.getFilteredByTag("post").filter(item => {
    const innerConfig = getSiteConfig(); // CALLED N TIMES!
    return innerConfig.showDrafts || !item.data.draft;
  });
});
```

**Efficient (Memoized):**

```javascript
let _siteConfig = null;
function getSiteConfig() {
  if (!_siteConfig) {
    _siteConfig = JSON.parse(fs.readFileSync("./site.json", "utf8"));
  }
  return _siteConfig;
}
```

Now, no matter how many times `getSiteConfig()` is called, the file is only read once.

---

## Deep Comparisons Are Expensive

Avoid comparing objects by their full structure inside loops.

**Slow:**

```javascript
.filter(item => JSON.stringify(item.data) === JSON.stringify(target));
```

`JSON.stringify` is surprisingly slow and creates garbage for the GC. For 10,000 items, you're serializing and comparing 10,000 objects.

**Fast:**

```javascript
.filter(item => item.url === target.url);
```

Comparing primitives (strings, numbers, booleans) is orders of magnitude faster than object serialization.

---

## Profiling Your Build

When build times balloon, you need data, not guesses.

**Enable Eleventy Benchmarks:**

```bash
DEBUG=Eleventy:Benchmark* npx @11ty/eleventy
```

This prints timing information for various stages, helping you identify which collections (or templates) are the bottleneck.

**Manual Timing:**

```javascript
eleventyConfig.addCollection("debugPosts", collection => {
  const start = Date.now();
  
  const result = collection.getFilteredByTag("post")
    .filter(item => item.data.published);
  
  console.log(`[Collection: posts] ${Date.now() - start}ms, ${result.length} items`);
  return result;
});
```

If you see a specific collection taking seconds, you know where to focus optimization efforts.

---

## Common Pitfalls and Solutions

**Problem:** Build time grows linearly with content count.

**Solution:** Replace `getAll().filter()` with `getFilteredByTag()` or `getFilteredByGlob()`. Use file-system organization (folders) to naturally segment content.

---

**Problem:** A single collection takes disproportionately long.

**Solution:** Profile it with `Date.now()`. Look for I/O operations, heavy string processing, or nested loops inside the filter callback.

---

**Problem:** Helper functions are slow because they re-compute on every call.

**Solution:** Memoize results. Cache expensive computations in module-level variables so they only run once per build.

---

**Problem:** Sorting is slow.

**Solution:** Ensure you're sorting *after* filtering. Sorting 50 items is fast; sorting 10,000 is measurable. Also, avoid complex sort comparisons—parse dates to timestamps once, not in every comparison.

---

## A Coherent System

When viewed as a complete system, Collection performance optimization follows consistent principles:

- **Filter Early**: Reduce the dataset before transforming.
- **Use Indexes**: Leverage Eleventy's built-in tag and glob indexes.
- **Avoid I/O**: Never read files inside callbacks; use Front Matter.
- **Memoize**: Cache expensive external lookups.
- **Measure**: Profile before guessing. Data beats intuition.

In practical terms, a well-optimized 10,000-page site should build in under a minute. A poorly optimized one can take 10+ minutes, ruining the development feedback loop.

**The essence:** Collection performance isn't about micro-optimization tricks—it's about respecting the build-time paradigm where every operation happens once per build, not once per request. Design your data flow so filtering is cheap and fast, and your sites will scale gracefully.

---

## Quick Reference

| Concept | Recommendation |
| :--- | :--- |
| **`getAll()` vs `getFilteredByTag()`** | Prefer specific methods for tags/globs over `.getAll().filter()` |
| **Filter Order** | Filter to reduce set size BEFORE mapping/transforming |
| **I/O in Loops** | Never. Use Front Matter or pre-computed data files instead. |
| **Memoization** | Cache any external lookups at module scope |
| **Sorting** | Sort AFTER filtering to minimize items to compare |
| **Profiling** | Use `DEBUG=Eleventy:Benchmark*` or manual `Date.now()` timing |
| **Object Comparison** | Compare primitives (urls, slugs, ids), not full objects |

---

_This guide establishes the foundation for performant collection design. Natural progressions include exploring **incremental builds**, **caching strategies**, and **parallel processing with worker threads**._
