# Eleventy Collection Sorting: A Professional Mental Model

Sorting collections determines the order in which content appears on your site—whether blog posts display newest-first, documentation pages follow a logical sequence, or team members list alphabetically. Understanding Eleventy's default sorting behavior and how to customize it transforms what might seem like random order into predictable, controlled output.

---

## The Fundamental Principle: Date as the Universal Sorter

By default, Eleventy sorts all collections by **date in ascending order** (oldest first). This isn't arbitrary—it reflects the common need for chronological archives where the first post in a series appears at the top and subsequent posts follow in order.

Think of Eleventy's default sort as a **timeline**. The horizontal axis represents time, left to right, from past to future. When you iterate over a collection without reversing it, you're walking that timeline from its origin (oldest content) toward the present (newest content).

This design immediately implies that if you want "newest first" (the standard blog pattern), you must **explicitly reverse** the collection. Eleventy won't assume what you want—it gives you a consistent base behavior you can modify.

---

## Where Does the Date Come From?

The `date` property on each collection item can come from multiple sources, and understanding the priority order prevents confusion.

**Priority Order (Highest to Lowest):**

1. **Explicit Front Matter**: `date: 2024-05-15`
2. **Filename Date**: `2024-05-15-my-post.md` (Eleventy extracts the date)
3. **Git Last Modified** (if configured): Uses repository commit dates
4. **File System Creation Date**: Falls back to OS-level file metadata

```yaml
---
title: "My Post"
date: 2024-05-15
---
```

When you set `date` explicitly in front matter, you have complete control. The filename and file system dates become irrelevant. This is the **recommended practice** for production sites where sort order matters.

---

## The Filename Date Pattern

Eleventy recognizes dates embedded in filenames using the `YYYY-MM-DD-` prefix:

```
posts/
├── 2024-01-10-first-post.md
├── 2024-01-15-second-post.md
└── 2024-01-20-third-post.md
```

Without any front matter date, these posts sort chronologically:
1. first-post (Jan 10)
2. second-post (Jan 15)
3. third-post (Jan 20)

The date is extracted and used for sorting, but the slug/URL strips the date prefix by default. `2024-01-10-first-post.md` becomes `/posts/first-post/`.

**Gotcha:** If you have both a filename date AND a front matter date that differ, the front matter wins. This can cause confusing behavior if you rename a file but forget to update the front matter.

---

## The File System Fallback (Why It's Dangerous)

When no explicit date exists, Eleventy uses the file's creation time from the operating system. This is **unreliable** for several reasons:

- **Git doesn't preserve timestamps**: Cloning a repo sets all creation dates to "now"
- **Different filesystems behave differently**: Windows, macOS, and Linux report different metadata
- **Copy/paste operations reset dates**: Moving files to a new location resets creation time

The result: A blog that builds perfectly on your machine may produce a completely different post order when built on a CI server or a colleague's computer.

**Solution:** Always set explicit dates in front matter for any content where order matters.

---

## Default Behavior in Tag Collections

When you create a tag-based collection (`tags: post`), the items are automatically sorted by date ascending:

```javascript
// This is what Eleventy does internally (simplified)
collections.post.sort((a, b) => a.date - b.date);
```

The oldest post appears at index `[0]`, the newest at `[length - 1]`.

**Displaying Newest First:**

```html
{% for post in collections.post | reverse %}
  <li>{{ post.data.title }}</li>
{% endfor %}
```

The `| reverse` filter (Nunjucks/Liquid) flips the array without modifying the original collection.

---

## Custom Collections Inherit No Default Sort

When you create a collection via `addCollection`, **you are responsible for sorting**:

```javascript
eleventyConfig.addCollection("myPosts", collection => {
  return collection.getFilteredByTag("post");
  // Items are ALREADY sorted by date ascending
});
```

However, if you apply additional filtering or mapping, you may inadvertently change the order. Always verify the final sort matches your expectations.

**Explicit Re-Sort After Filtering:**

```javascript
eleventyConfig.addCollection("myPosts", collection => {
  return collection.getFilteredByTag("post")
    .filter(item => item.data.featured)
    .sort((a, b) => b.date - a.date); // Newest first
});
```

---

## Common Pitfalls and Solutions

**Problem:** Posts appear in random order on different machines.

**Cause:** No explicit `date` in front matter; relying on file system timestamps.

**Solution:** Add `date:` to the front matter of every post.

---

**Problem:** Newest post appears at the bottom of the list.

**Cause:** Default ascending sort (oldest first).

**Solution:** Use `| reverse` filter or sort descending with `.sort((a, b) => b.date - a.date)`.

---

**Problem:** Posts with the same date appear in unpredictable order.

**Cause:** JavaScript sort is not guaranteed stable for equal values.

**Solution:** Add a secondary sort key (e.g., title alphabetically):

```javascript
.sort((a, b) => {
  const dateDiff = b.date - a.date;
  if (dateDiff !== 0) return dateDiff;
  return a.data.title.localeCompare(b.data.title);
});
```

---

**Problem:** Filename date and front matter date conflict.

**Cause:** File was renamed but front matter not updated.

**Solution:** Audit your content. Choose one date source and use it consistently.

---

## A Coherent System

When viewed as a complete system, Eleventy's default sorting architecture is **internally consistent**:

- Collections sort by date ascending by default
- Front matter dates take precedence over filename dates
- File system dates are a fallback, not a recommendation
- Custom collections must explicitly sort if order matters
- Reversing is trivial with template filters

In practical terms, default sorting means your oldest content anchors your timelines. This works naturally for series ("Part 1", "Part 2"...) but requires reversal for blogs where freshness wins.

**The essence:** Sorting in Eleventy is predictable but not presumptuous. It gives you a chronological baseline and expects you to communicate your intent (newest first, alphabetical, custom order) explicitly. This is not complexity—it's respect for your design decisions.

---

## Quick Reference

| Concept | Key Point |
| :--- | :--- |
| **Default Sort** | Ascending by `date` (oldest → newest) |
| **Date Priority** | Front Matter > Filename > File System |
| **Filename Pattern** | `YYYY-MM-DD-slug.md` is auto-parsed |
| **Newest First** | Use `| reverse` filter or `.sort((a,b) => b.date - a.date)` |
| **Stable Secondary Sort** | Use `localeCompare()` for strings, numeric subtraction for dates |
| **Custom Collections** | No implicit sort—you must sort explicitly if you filter |

---

_This guide establishes the foundation for collection sorting. Natural progressions include exploring **sorting by custom fields**, **order keys for manual sequencing**, and **grouping with sorted subsections**._
