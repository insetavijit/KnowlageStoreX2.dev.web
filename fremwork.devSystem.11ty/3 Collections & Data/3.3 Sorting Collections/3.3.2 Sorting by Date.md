# Sorting by Date: Explicit Chronological Control

While Eleventy's default sort is date-based, **explicit date sorting** means taking deliberate controlâ€”specifying the date field reliably and configuring sort direction to match your content strategy. This is the difference between hoping your posts appear correctly and knowing they will.

---

## The Fundamental Principle: Dates Are Numeric

JavaScript Date objects can be compared directly using subtraction:

```javascript
const earlier = new Date("2024-01-01");
const later = new Date("2024-06-15");

console.log(later - earlier); // Positive number (later is bigger)
console.log(earlier - later); // Negative number (earlier is smaller)
```

This numeric comparison is the foundation of date sorting. When you write `a.date - b.date`, you're asking: "How much later is A than B?" The sign of the result determines sort order.

---

## Ascending vs. Descending

**Ascending (Oldest First):**

```javascript
.sort((a, b) => a.date - b.date)
```

If `a` is older, `a.date` is smaller, so `a.date - b.date` is negative, placing `a` before `b`.

**Descending (Newest First):**

```javascript
.sort((a, b) => b.date - a.date)
```

Swapping `a` and `b` reverses the comparison. If `b` is newer, `b.date` is larger, resulting in a positive number that places `b` before `a`.

**The Blog Pattern:**

Most blogs want "Newest First" (descending). In a custom collection:

```javascript
eleventyConfig.addCollection("posts", collection => {
  return collection.getFilteredByTag("post")
    .sort((a, b) => b.date - a.date);
});
```

Or, using the template filter:

```html
{% for post in collections.post | reverse %}
```

Both achieve the same result. Choose based on whether you want the sort in your config (global) or template (local).

---

## Setting Dates Explicitly

The `date` field in front matter accepts multiple formats:

**ISO 8601 (Recommended):**

```yaml
date: 2024-05-15T14:30:00Z
```

**Date Only:**

```yaml
date: 2024-05-15
```

**Special Values:**

```yaml
date: Last Modified  # Uses file modification time (Git or FS)
date: Created         # Uses file creation time
date: git Last Modified  # Explicitly uses Git commit date
```

The special values are useful for documentation sites where "Last Modified" helps surface recently updated content.

---

## Handling Timezone Issues

Dates without explicit timezone offsets are interpreted in **local time** during the build. This can cause issues when:

1. You build locally in EST but deploy from a CI server in UTC
2. You set `date: 2024-01-01` but it becomes `2023-12-31` in certain timezones

**Solution:** Always use ISO 8601 with timezone:

```yaml
date: 2024-01-01T00:00:00+00:00
```

Or, at minimum, include a time component that gives buffer:

```yaml
date: 2024-01-01T12:00:00
```

Noon is safe across most timezone interpretations.

---

## Validating Dates in Collections

Invalid dates break sorting. If one item has `date: "not-a-date"`, comparison fails:

```javascript
NaN - someDateTimestamp = NaN
```

This can cause completely scrambled results.

**Defensive Coding:**

```javascript
eleventyConfig.addCollection("safePosts", collection => {
  return collection.getFilteredByTag("post")
    .filter(item => {
      const valid = item.date instanceof Date && !isNaN(item.date);
      if (!valid) console.warn(`Invalid date: ${item.inputPath}`);
      return valid;
    })
    .sort((a, b) => b.date - a.date);
});
```

This logs warnings for problematic files rather than silently producing incorrect order.

---

## Multiple Date Fields

Some content has multiple relevant dates:

- `date`: Original publication
- `updated`: Last revision
- `event_date`: When an event occurs

You can sort by any of these by accessing `item.data.fieldName`:

```javascript
.sort((a, b) => {
  const dateA = a.data.event_date || a.date;
  const dateB = b.data.event_date || b.date;
  return new Date(dateA) - new Date(dateB);
})
```

**Fallback Pattern:** Use `event_date` if available, otherwise fall back to standard `date`.

---

## Common Pitfalls and Solutions

**Problem:** Posts with the same date appear in random order.

**Solution:** Add a secondary sort criterion:

```javascript
.sort((a, b) => {
  const dateDiff = b.date - a.date;
  if (dateDiff !== 0) return dateDiff;
  return a.data.title.localeCompare(b.data.title);
});
```

---

**Problem:** Sorting seems correct locally but wrong in production.

**Cause:** Timezone differences between local machine and CI server.

**Solution:** Use explicit timezones in ISO 8601 format.

---

**Problem:** Some posts have no date and sink to the top/bottom unexpectedly.

**Solution:** Filter them out or provide a sensible default:

```javascript
const safeDate = item => item.date || new Date(0); // Epoch as fallback
```

---

## Quick Reference

| Pattern | Code | Result |
| :--- | :--- | :--- |
| **Oldest First** | `a.date - b.date` | Chronological |
| **Newest First** | `b.date - a.date` | Reverse Chronological |
| **Template Reverse** | `\| reverse` | Flips array in Nunjucks/Liquid |
| **Safe Comparison** | Check `instanceof Date` | Prevents NaN issues |
| **Timezone Safe** | `2024-01-01T12:00:00+00:00` | Avoid date shifting |

---

_This guide covers date-based sorting. Natural progressions include **sorting by custom order keys**, **alphabetical sorting**, and **multi-field sorting strategies**._
