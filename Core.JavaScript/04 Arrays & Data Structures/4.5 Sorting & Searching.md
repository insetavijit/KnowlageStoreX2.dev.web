# **[[4.5 Sorting & Searching]]**

## Overview

This topic covers sorting and searching arrays. You'll learn the sort method with custom comparators, reverse for order inversion, and searching techniques with indexOf, find, and binary search concepts.

## Sort Method

Sort arrays in place.

**Basic Sort (Alphabetical):**
```javascript
let fruits = ["banana", "apple", "orange", "mango"];
fruits.sort();
console.log(fruits);  // ["apple", "banana", "mango", "orange"]

// Mutates original array
let letters = ["c", "a", "b"];
letters.sort();  // letters is now ["a", "b", "c"]
```

**Number Sort Problem:**
```javascript
let numbers = [10, 2, 30, 5, 100];
numbers.sort();
console.log(numbers);  // [10, 100, 2, 30, 5] - Wrong!
// Default sort converts to strings: "10" < "100" < "2"
```

**Numeric Sort:**
```javascript
let numbers = [10, 2, 30, 5, 100];

// Ascending
numbers.sort((a, b) => a - b);
console.log(numbers);  // [2, 5, 10, 30, 100]

// Descending
numbers.sort((a, b) => b - a);
console.log(numbers);  // [100, 30, 10, 5, 2]
```

## Custom Comparators

Define custom sorting logic.

**Comparator Function:**
```javascript
// Returns:
// - Negative: a comes before b
// - Zero: keep original order
// - Positive: b comes before a

let numbers = [3, 1, 4, 1, 5, 9];

numbers.sort((a, b) => {
    if (a < b) return -1;  // a first
    if (a > b) return 1;   // b first
    return 0;              // keep order
});
```

**Sort Objects:**
```javascript
let users = [
    { name: "Charlie", age: 25 },
    { name: "Alice", age: 30 },
    { name: "Bob", age: 20 }
];

// Sort by age
users.sort((a, b) => a.age - b.age);

// Sort by name
users.sort((a, b) => a.name.localeCompare(b.name));
```

**Multiple Criteria:**
```javascript
let items = [
    { category: "A", priority: 2 },
    { category: "B", priority: 1 },
    { category: "A", priority: 1 }
];

// Sort by category, then by priority
items.sort((a, b) => {
    if (a.category !== b.category) {
        return a.category.localeCompare(b.category);
    }
    return a.priority - b.priority;
});
```

**Case-Insensitive:**
```javascript
let words = ["Apple", "banana", "Cherry"];

words.sort((a, b) => 
    a.toLowerCase().localeCompare(b.toLowerCase())
);
// ["Apple", "banana", "Cherry"]
```

## Reverse

Reverse array order in place.

**Basic Reverse:**
```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr);  // [5, 4, 3, 2, 1]
```

**Reverse String:**
```javascript
let str = "hello";
let reversed = str.split("").reverse().join("");
console.log(reversed);  // "olleh"
```

**Combined with Sort:**
```javascript
let numbers = [3, 1, 4, 1, 5];

// Descending order
numbers.sort((a, b) => a - b).reverse();
// Or directly: numbers.sort((a, b) => b - a);
```

**Non-Mutating Reverse:**
```javascript
let original = [1, 2, 3];

// Create reversed copy
let reversed = [...original].reverse();
// Or
let reversed2 = original.slice().reverse();

console.log(original);  // [1, 2, 3] (unchanged)
console.log(reversed);  // [3, 2, 1]
```

## Searching Arrays

Find elements and their positions.

**indexOf/lastIndexOf:**
```javascript
let arr = ["a", "b", "c", "b", "d"];

arr.indexOf("b");       // 1 (first occurrence)
arr.lastIndexOf("b");   // 3 (last occurrence)
arr.indexOf("z");       // -1 (not found)

// With start position
arr.indexOf("b", 2);    // 3 (search from index 2)
```

**includes:**
```javascript
let numbers = [1, 2, 3, NaN];

numbers.includes(2);     // true
numbers.includes(5);     // false
numbers.includes(NaN);   // true (finds NaN, unlike indexOf)
```

**find/findIndex:**
```javascript
let users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

let user = users.find(u => u.id === 2);
// { id: 2, name: "Bob" }

let index = users.findIndex(u => u.id === 2);
// 1
```

**Binary Search (Sorted Arrays):**
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;  // Not found
}

let sorted = [1, 3, 5, 7, 9, 11, 13];
binarySearch(sorted, 7);   // 3
binarySearch(sorted, 8);   // -1
```

## Sorting Algorithms

Understanding sort behavior and complexity.

**JavaScript Sort:**
```javascript
// V8 Engine (Chrome, Node): TimSort (O(n log n))
// Other engines may vary
// Stable sort in modern JavaScript (ES2019+)

let items = [
    { name: "A", value: 1 },
    { name: "B", value: 1 },
    { name: "C", value: 2 }
];

// Stable: equal elements keep original order
items.sort((a, b) => a.value - b.value);
// A still comes before B
```

**Stable vs Unstable:**
```javascript
// Stable: Equal elements maintain relative order
// Modern JS sort is stable

let data = [
    { name: "first", key: 1 },
    { name: "second", key: 1 },
    { name: "third", key: 2 }
];

data.sort((a, b) => a.key - b.key);
// first still comes before second (both have key: 1)
```

**toSorted (ES2023):**
```javascript
let numbers = [3, 1, 4, 1, 5];

// Returns new sorted array, original unchanged
let sorted = numbers.toSorted((a, b) => a - b);

console.log(numbers);  // [3, 1, 4, 1, 5] (unchanged)
console.log(sorted);   // [1, 1, 3, 4, 5]
```

**toReversed (ES2023):**
```javascript
let arr = [1, 2, 3];

let reversed = arr.toReversed();

console.log(arr);      // [1, 2, 3] (unchanged)
console.log(reversed); // [3, 2, 1]
```

## Summary / Key Takeaways

- **sort():** Mutates array; defaults to string comparison
- **Numeric sort:** Use `(a, b) => a - b` for ascending
- **Custom comparator:** Negative, zero, or positive return values
- **localeCompare:** For proper string comparison (case, locale)
- **reverse():** Mutates array; reverses element order
- **indexOf/includes:** Find elements; includes finds NaN
- **find/findIndex:** Search with predicate function
- **Binary search:** O(log n) for sorted arrays
- **toSorted/toReversed:** Non-mutating alternatives (ES2023)
- **Stable sort:** Equal elements keep original order (ES2019+)

Sorting and searching are fundamental operations for organizing and accessing array data.
