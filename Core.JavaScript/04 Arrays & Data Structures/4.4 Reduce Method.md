# **[[4.4 Reduce Method]]**

## Overview

This topic covers the powerful reduce method. You'll learn reduce syntax and mechanics, accumulator and initial value concepts, common reduction patterns, and practical use cases for aggregating data.

## Reduce Syntax

Reduce processes array elements into a single value.

**Syntax:**
```javascript
array.reduce((accumulator, currentValue, index, array) => {
    return newAccumulator;
}, initialValue);
```

**Basic Sum:**
```javascript
let numbers = [1, 2, 3, 4, 5];

let sum = numbers.reduce((acc, num) => {
    return acc + num;
}, 0);

console.log(sum);  // 15
```

**Step by Step:**
```javascript
[1, 2, 3].reduce((acc, num) => acc + num, 0);
// Iteration 1: acc=0, num=1 → returns 1
// Iteration 2: acc=1, num=2 → returns 3
// Iteration 3: acc=3, num=3 → returns 6
// Final result: 6
```

**Arrow Function Shorthand:**
```javascript
let sum = [1, 2, 3, 4, 5].reduce((acc, n) => acc + n, 0);
let product = [1, 2, 3, 4].reduce((acc, n) => acc * n, 1);
```

## Accumulator

The accumulated result passed between iterations.

**Accumulator Types:**
```javascript
// Number accumulator
let sum = [1, 2, 3].reduce((acc, n) => acc + n, 0);

// String accumulator
let joined = ["a", "b", "c"].reduce((acc, s) => acc + s, "");

// Array accumulator
let doubled = [1, 2, 3].reduce((acc, n) => {
    acc.push(n * 2);
    return acc;
}, []);

// Object accumulator
let counts = ["a", "b", "a"].reduce((acc, char) => {
    acc[char] = (acc[char] || 0) + 1;
    return acc;
}, {});
```

**Always Return Accumulator:**
```javascript
// Wrong: forgetting to return
let result = [1, 2, 3].reduce((acc, n) => {
    acc.push(n);
    // Missing return!
}, []);
// result is undefined

// Correct
let result = [1, 2, 3].reduce((acc, n) => {
    acc.push(n);
    return acc;  // Must return
}, []);
```

## Initial Value

The starting value for the accumulator.

**With Initial Value:**
```javascript
let numbers = [1, 2, 3];

// Initial value 0
numbers.reduce((acc, n) => acc + n, 0);  // 6

// Initial value 10
numbers.reduce((acc, n) => acc + n, 10); // 16
```

**Without Initial Value:**
```javascript
let numbers = [1, 2, 3];

// First element becomes initial accumulator
numbers.reduce((acc, n) => acc + n);
// Iteration 1: acc=1, n=2 → 3
// Iteration 2: acc=3, n=3 → 6
```

**Danger Without Initial Value:**
```javascript
// Empty array throws error
[].reduce((acc, n) => acc + n);  // TypeError!

// Safe with initial value
[].reduce((acc, n) => acc + n, 0);  // 0

// Always provide initial value for safety
```

**Matching Type:**
```javascript
// Initial value should match intended result type
[1, 2, 3].reduce((acc, n) => acc + n, 0);      // Number
[1, 2, 3].reduce((acc, n) => [...acc, n], []); // Array
[1, 2, 3].reduce((acc, n) => ({ ...acc, [n]: true }), {}); // Object
```

## Common Patterns

Frequently used reduce patterns.

**Sum/Product:**
```javascript
let sum = [1, 2, 3, 4, 5].reduce((a, b) => a + b, 0);  // 15
let product = [1, 2, 3, 4].reduce((a, b) => a * b, 1); // 24
```

**Min/Max:**
```javascript
let numbers = [5, 2, 8, 1, 9];

let max = numbers.reduce((max, n) => n > max ? n : max, -Infinity);
let min = numbers.reduce((min, n) => n < min ? n : min, Infinity);

// Or use Math.max/min with spread
Math.max(...numbers);  // 9
```

**Flatten Array:**
```javascript
let nested = [[1, 2], [3, 4], [5, 6]];

let flat = nested.reduce((acc, arr) => [...acc, ...arr], []);
// [1, 2, 3, 4, 5, 6]

// Or use flat()
nested.flat();  // [1, 2, 3, 4, 5, 6]
```

**Count Occurrences:**
```javascript
let letters = ["a", "b", "a", "c", "b", "a"];

let counts = letters.reduce((acc, letter) => {
    acc[letter] = (acc[letter] || 0) + 1;
    return acc;
}, {});
// { a: 3, b: 2, c: 1 }
```

**Group By:**
```javascript
let people = [
    { name: "Alice", dept: "Sales" },
    { name: "Bob", dept: "IT" },
    { name: "Charlie", dept: "Sales" }
];

let byDept = people.reduce((acc, person) => {
    let dept = person.dept;
    if (!acc[dept]) acc[dept] = [];
    acc[dept].push(person);
    return acc;
}, {});
// { Sales: [...], IT: [...] }
```

## Practical Examples

Real-world reduce applications.

**Shopping Cart Total:**
```javascript
let cart = [
    { name: "Shirt", price: 20, qty: 2 },
    { name: "Pants", price: 40, qty: 1 },
    { name: "Shoes", price: 60, qty: 1 }
];

let total = cart.reduce((sum, item) => {
    return sum + (item.price * item.qty);
}, 0);
// 140
```

**Compose Functions:**
```javascript
const compose = (...fns) => (value) => 
    fns.reduceRight((acc, fn) => fn(acc), value);

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const transform = compose(square, double, addOne);
transform(3);  // ((3 + 1) * 2)² = 64
```

**Build Query String:**
```javascript
let params = { name: "John", age: 30, city: "NYC" };

let queryString = Object.entries(params).reduce((str, [key, value], index) => {
    return str + (index === 0 ? "?" : "&") + `${key}=${value}`;
}, "");
// "?name=John&age=30&city=NYC"
```

**Promises in Sequence:**
```javascript
let urls = ["/api/1", "/api/2", "/api/3"];

let results = urls.reduce((promise, url) => {
    return promise.then(results => 
        fetch(url)
            .then(res => res.json())
            .then(data => [...results, data])
    );
}, Promise.resolve([]));
```

**Implement Map with Reduce:**
```javascript
function myMap(array, fn) {
    return array.reduce((acc, item, index) => {
        acc.push(fn(item, index, array));
        return acc;
    }, []);
}

myMap([1, 2, 3], x => x * 2);  // [2, 4, 6]
```

**Implement Filter with Reduce:**
```javascript
function myFilter(array, predicate) {
    return array.reduce((acc, item, index) => {
        if (predicate(item, index, array)) {
            acc.push(item);
        }
        return acc;
    }, []);
}

myFilter([1, 2, 3, 4], x => x % 2 === 0);  // [2, 4]
```

## reduceRight

Process array from right to left.

**Basic Usage:**
```javascript
let letters = ["a", "b", "c", "d"];

letters.reduce((acc, l) => acc + l, "");       // "abcd"
letters.reduceRight((acc, l) => acc + l, "");  // "dcba"
```

**Function Composition:**
```javascript
// compose: right-to-left
const compose = (...fns) => x => 
    fns.reduceRight((acc, fn) => fn(acc), x);

// pipe: left-to-right  
const pipe = (...fns) => x => 
    fns.reduce((acc, fn) => fn(acc), x);
```

## Summary / Key Takeaways

- **Reduce syntax:** `array.reduce((acc, val) => newAcc, initialValue)`
- **Accumulator:** Carries result between iterations; must be returned
- **Initial value:** Starting point for accumulator; always provide for safety
- **Without initial:** First element becomes initial; empty array throws error
- **Common patterns:** Sum, count, group by, flatten, compose
- **Accumulator types:** Can be number, string, array, object, or any type
- **reduceRight:** Same as reduce but processes from end to start
- **Power:** Can implement map, filter, and most array operations with reduce

Reduce is the most versatile array method, capable of expressing any array transformation.
