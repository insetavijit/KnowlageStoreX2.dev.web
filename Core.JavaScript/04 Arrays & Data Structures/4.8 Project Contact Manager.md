# **[[4.8 Project: Contact Manager]]**

## Overview

This hands-on project applies array concepts to build a contact manager. You'll implement CRUD operations on an array of contacts, use array methods for searching and filtering, and practice data manipulation patterns.

## Project Goals

Build a contact manager that can:
- Add, edit, and delete contacts
- Search by name, email, or phone
- Filter by groups or favorites
- Sort contacts
- Import/export data

## Project Setup

**Create Project Files:**
```
contact-manager/
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ contacts.js
‚îî‚îÄ‚îÄ README.md
```

**index.html:**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Contact Manager</title>
</head>
<body>
    <h1>Contact Manager</h1>
    <p>Open console (F12) to use the contact manager</p>
    <script src="contacts.js"></script>
</body>
</html>
```

## Building the Contact Manager

**Version 1: Basic CRUD**

```javascript
// contacts.js

// Contact storage
let contacts = [];
let nextId = 1;

// CREATE
function addContact(name, email, phone, group = "general") {
    // Validate required fields
    if (!name || !email) {
        console.error("‚ùå Name and email are required");
        return null;
    }
    
    // Check for duplicate email
    if (contacts.some(c => c.email === email)) {
        console.error("‚ùå Email already exists");
        return null;
    }
    
    const contact = {
        id: nextId++,
        name,
        email,
        phone: phone || null,
        group,
        favorite: false,
        createdAt: new Date(),
        updatedAt: new Date()
    };
    
    contacts.push(contact);
    console.log(`‚úÖ Added: ${name}`);
    return { ...contact };  // Return copy
}

// READ
function getAllContacts() {
    return contacts.map(c => ({ ...c }));  // Return copies
}

function getContactById(id) {
    const contact = contacts.find(c => c.id === id);
    return contact ? { ...contact } : null;
}

// UPDATE
function updateContact(id, updates) {
    const index = contacts.findIndex(c => c.id === id);
    if (index === -1) {
        console.error(`‚ùå Contact #${id} not found`);
        return null;
    }
    
    // Validate email uniqueness if changing
    if (updates.email && updates.email !== contacts[index].email) {
        if (contacts.some(c => c.email === updates.email)) {
            console.error("‚ùå Email already exists");
            return null;
        }
    }
    
    contacts[index] = {
        ...contacts[index],
        ...updates,
        updatedAt: new Date()
    };
    
    console.log(`‚úÖ Updated: ${contacts[index].name}`);
    return { ...contacts[index] };
}

// DELETE
function deleteContact(id) {
    const index = contacts.findIndex(c => c.id === id);
    if (index === -1) {
        console.error(`‚ùå Contact #${id} not found`);
        return false;
    }
    
    const deleted = contacts.splice(index, 1)[0];
    console.log(`üóëÔ∏è Deleted: ${deleted.name}`);
    return true;
}

// Test CRUD
addContact("Alice Smith", "alice@example.com", "555-0101", "work");
addContact("Bob Johnson", "bob@example.com", "555-0102", "personal");
addContact("Charlie Brown", "charlie@example.com");
console.table(getAllContacts());
```

**Version 2: Search and Filter**

```javascript
// SEARCH
function searchContacts(query) {
    const lowerQuery = query.toLowerCase();
    
    return contacts.filter(contact => 
        contact.name.toLowerCase().includes(lowerQuery) ||
        contact.email.toLowerCase().includes(lowerQuery) ||
        (contact.phone && contact.phone.includes(query))
    ).map(c => ({ ...c }));
}

// FILTER by group
function getContactsByGroup(group) {
    return contacts
        .filter(c => c.group === group)
        .map(c => ({ ...c }));
}

// FILTER favorites
function getFavorites() {
    return contacts
        .filter(c => c.favorite)
        .map(c => ({ ...c }));
}

// Toggle favorite
function toggleFavorite(id) {
    const contact = contacts.find(c => c.id === id);
    if (!contact) {
        console.error(`‚ùå Contact #${id} not found`);
        return null;
    }
    
    contact.favorite = !contact.favorite;
    const status = contact.favorite ? "added to" : "removed from";
    console.log(`‚≠ê ${contact.name} ${status} favorites`);
    return { ...contact };
}

// Get all groups
function getGroups() {
    return [...new Set(contacts.map(c => c.group))];
}

// Count by group
function countByGroup() {
    return contacts.reduce((acc, contact) => {
        acc[contact.group] = (acc[contact.group] || 0) + 1;
        return acc;
    }, {});
}
```

**Version 3: Sorting and Display**

```javascript
// SORT
function sortContacts(field = "name", order = "asc") {
    const sorted = [...contacts].sort((a, b) => {
        let valA = a[field];
        let valB = b[field];
        
        // Handle null values
        if (valA === null) return 1;
        if (valB === null) return -1;
        
        // String comparison
        if (typeof valA === "string") {
            return order === "asc" 
                ? valA.localeCompare(valB)
                : valB.localeCompare(valA);
        }
        
        // Number/Date comparison
        return order === "asc" ? valA - valB : valB - valA;
    });
    
    return sorted.map(c => ({ ...c }));
}

// DISPLAY
function displayContacts(list = contacts, title = "Contacts") {
    console.log(`\nüìá ${title}`);
    console.log("‚ïê".repeat(60));
    
    if (list.length === 0) {
        console.log("No contacts found");
        return;
    }
    
    list.forEach(contact => {
        const star = contact.favorite ? "‚≠ê" : "  ";
        console.log(`${star} [${contact.id}] ${contact.name}`);
        console.log(`      üìß ${contact.email}`);
        if (contact.phone) {
            console.log(`      üìû ${contact.phone}`);
        }
        console.log(`      üìÅ ${contact.group}`);
    });
    
    console.log("‚ïê".repeat(60));
    console.log(`Total: ${list.length} contacts`);
}

// STATS
function getStats() {
    return {
        total: contacts.length,
        favorites: getFavorites().length,
        byGroup: countByGroup(),
        recentlyAdded: contacts
            .sort((a, b) => b.createdAt - a.createdAt)
            .slice(0, 5)
            .map(c => c.name)
    };
}
```

**Version 4: Complete Application**

```javascript
// contacts.js - Complete Version

const ContactManager = (function() {
    // Private state
    let contacts = [];
    let nextId = 1;
    
    // Private helpers
    function findById(id) {
        return contacts.find(c => c.id === id);
    }
    
    function findIndexById(id) {
        return contacts.findIndex(c => c.id === id);
    }
    
    function validateEmail(email) {
        return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
    }
    
    function copyContact(contact) {
        return { ...contact };
    }
    
    // Public API
    return {
        // CREATE
        add(data) {
            const { name, email, phone, group = "general" } = data;
            
            if (!name || !email) {
                throw new Error("Name and email are required");
            }
            
            if (!validateEmail(email)) {
                throw new Error("Invalid email format");
            }
            
            if (contacts.some(c => c.email.toLowerCase() === email.toLowerCase())) {
                throw new Error("Email already exists");
            }
            
            const contact = {
                id: nextId++,
                name: name.trim(),
                email: email.toLowerCase().trim(),
                phone: phone || null,
                group,
                favorite: false,
                notes: "",
                createdAt: new Date(),
                updatedAt: new Date()
            };
            
            contacts.push(contact);
            return copyContact(contact);
        },
        
        // READ
        getAll() {
            return contacts.map(copyContact);
        },
        
        getById(id) {
            const contact = findById(id);
            return contact ? copyContact(contact) : null;
        },
        
        // UPDATE
        update(id, updates) {
            const index = findIndexById(id);
            if (index === -1) return null;
            
            // Don't allow id changes
            delete updates.id;
            delete updates.createdAt;
            
            // Validate email if changing
            if (updates.email) {
                updates.email = updates.email.toLowerCase().trim();
                if (!validateEmail(updates.email)) {
                    throw new Error("Invalid email format");
                }
                const existing = contacts.find(c => 
                    c.email === updates.email && c.id !== id
                );
                if (existing) {
                    throw new Error("Email already exists");
                }
            }
            
            contacts[index] = {
                ...contacts[index],
                ...updates,
                updatedAt: new Date()
            };
            
            return copyContact(contacts[index]);
        },
        
        // DELETE
        delete(id) {
            const index = findIndexById(id);
            if (index === -1) return false;
            contacts.splice(index, 1);
            return true;
        },
        
        deleteMany(ids) {
            const deleted = ids.filter(id => this.delete(id));
            return deleted.length;
        },
        
        // FAVORITE
        toggleFavorite(id) {
            const contact = findById(id);
            if (!contact) return null;
            contact.favorite = !contact.favorite;
            contact.updatedAt = new Date();
            return copyContact(contact);
        },
        
        getFavorites() {
            return contacts.filter(c => c.favorite).map(copyContact);
        },
        
        // SEARCH & FILTER
        search(query) {
            if (!query) return this.getAll();
            const q = query.toLowerCase();
            return contacts.filter(c =>
                c.name.toLowerCase().includes(q) ||
                c.email.includes(q) ||
                (c.phone && c.phone.includes(query)) ||
                (c.notes && c.notes.toLowerCase().includes(q))
            ).map(copyContact);
        },
        
        filterByGroup(group) {
            return contacts.filter(c => c.group === group).map(copyContact);
        },
        
        filter(predicate) {
            return contacts.filter(predicate).map(copyContact);
        },
        
        // SORT
        sort(field = "name", order = "asc") {
            return [...contacts].sort((a, b) => {
                let valA = a[field];
                let valB = b[field];
                
                if (valA === null) return 1;
                if (valB === null) return -1;
                
                if (typeof valA === "string") {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }
                
                if (valA < valB) return order === "asc" ? -1 : 1;
                if (valA > valB) return order === "asc" ? 1 : -1;
                return 0;
            }).map(copyContact);
        },
        
        // GROUPS
        getGroups() {
            return [...new Set(contacts.map(c => c.group))].sort();
        },
        
        setGroup(id, group) {
            return this.update(id, { group });
        },
        
        // STATS
        getStats() {
            const byGroup = contacts.reduce((acc, c) => {
                acc[c.group] = (acc[c.group] || 0) + 1;
                return acc;
            }, {});
            
            return {
                total: contacts.length,
                favorites: this.getFavorites().length,
                groups: this.getGroups().length,
                byGroup
            };
        },
        
        // IMPORT/EXPORT
        export() {
            return JSON.stringify(contacts, null, 2);
        },
        
        import(json) {
            try {
                const data = JSON.parse(json);
                if (!Array.isArray(data)) {
                    throw new Error("Invalid format");
                }
                contacts = data;
                nextId = Math.max(...contacts.map(c => c.id)) + 1;
                return contacts.length;
            } catch (e) {
                throw new Error("Failed to import: " + e.message);
            }
        },
        
        // DISPLAY
        display(list = contacts, title = "Contacts") {
            console.log(`\nüìá ${title}`);
            console.log("‚ïê".repeat(55));
            
            if (list.length === 0) {
                console.log("(no contacts)");
            } else {
                list.forEach(c => {
                    const star = c.favorite ? "‚≠ê" : "  ";
                    console.log(`${star}[${c.id}] ${c.name} <${c.email}>`);
                });
            }
            
            console.log("‚ïê".repeat(55));
            console.log(`üìä ${list.length} contact(s)\n`);
        }
    };
})();

// Demo
console.log("üìá Contact Manager Ready!");
console.log("Use ContactManager.add(), .search(), etc.");
```

## Concepts Applied

**Array Methods Used:**
- `push` - Add contacts
- `splice` - Delete contacts
- `find/findIndex` - Locate by ID
- `filter` - Search and group filtering
- `map` - Transform and copy
- `some` - Check duplicates
- `reduce` - Count by group
- `sort` - Order contacts
- `Set` - Unique groups

## Summary / Key Takeaways

- **CRUD operations** with array methods
- **Immutability** - return copies, don't expose internal state
- **Validation** - check required fields and uniqueness
- **Search** - filter with multiple field matching
- **Reduce** - aggregate data (count by group)
- **Set** - extract unique values (groups)
- **Module pattern** - encapsulate state and expose API
- **Import/export** - JSON serialization for persistence

This project demonstrates practical array manipulation for real-world data management.
