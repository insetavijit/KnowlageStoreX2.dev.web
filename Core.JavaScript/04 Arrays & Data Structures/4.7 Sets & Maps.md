# **[[4.7 Sets & Maps]]**

## Overview

This topic covers Set and Map data structures. You'll learn Set for unique values, Map for key-value pairs, WeakSet and WeakMap for memory management, when to use each structure, and conversion between types.

## Sets

Collections of unique values.

**Creating Sets:**
```javascript
let set = new Set();
set.add(1);
set.add(2);
set.add(3);

// From array
let set2 = new Set([1, 2, 3, 2, 1]);
console.log(set2);  // Set { 1, 2, 3 } (no duplicates)
```

**Set Methods:**
```javascript
let set = new Set([1, 2, 3]);

set.add(4);        // Add value
set.delete(2);     // Remove value
set.has(1);        // true - check existence
set.size;          // 3 - number of elements
set.clear();       // Remove all
```

**Iterating Sets:**
```javascript
let set = new Set(["a", "b", "c"]);

// forEach
set.forEach(value => console.log(value));

// for...of
for (let value of set) {
    console.log(value);
}

// Spread to array
let arr = [...set];  // ["a", "b", "c"]
```

**Remove Duplicates:**
```javascript
let numbers = [1, 2, 2, 3, 3, 3, 4];
let unique = [...new Set(numbers)];
// [1, 2, 3, 4]
```

**Set Operations:**
```javascript
let a = new Set([1, 2, 3]);
let b = new Set([2, 3, 4]);

// Union
let union = new Set([...a, ...b]);  // {1, 2, 3, 4}

// Intersection
let intersection = new Set([...a].filter(x => b.has(x)));  // {2, 3}

// Difference
let difference = new Set([...a].filter(x => !b.has(x)));  // {1}
```

## Maps

Key-value pairs with any key type.

**Creating Maps:**
```javascript
let map = new Map();
map.set("name", "Alice");
map.set("age", 25);

// From arrays
let map2 = new Map([
    ["key1", "value1"],
    ["key2", "value2"]
]);
```

**Map Methods:**
```javascript
let map = new Map();

map.set("a", 1);      // Set key-value
map.get("a");         // 1 - get value
map.has("a");         // true - check key
map.delete("a");      // Remove entry
map.size;             // Number of entries
map.clear();          // Remove all
```

**Any Key Type:**
```javascript
let map = new Map();

// Objects as keys
let objKey = { id: 1 };
map.set(objKey, "object value");
map.get(objKey);  // "object value"

// Functions as keys
let fnKey = () => {};
map.set(fnKey, "function value");

// NaN as key (works, unlike objects)
map.set(NaN, "NaN value");
map.get(NaN);  // "NaN value"
```

**Iterating Maps:**
```javascript
let map = new Map([
    ["a", 1],
    ["b", 2],
    ["c", 3]
]);

// for...of with destructuring
for (let [key, value] of map) {
    console.log(`${key}: ${value}`);
}

// forEach
map.forEach((value, key) => {
    console.log(`${key}: ${value}`);
});

// Get keys, values, entries
map.keys();     // Iterator of keys
map.values();   // Iterator of values
map.entries();  // Iterator of [key, value]

// Convert to array
let entries = [...map];  // [["a", 1], ["b", 2], ["c", 3]]
```

## WeakSet & WeakMap

Weak references that don't prevent garbage collection.

**WeakSet:**
```javascript
let weakSet = new WeakSet();

// Only objects allowed (not primitives)
let obj = { name: "Alice" };
weakSet.add(obj);
weakSet.has(obj);     // true
weakSet.delete(obj);  // true

// Cannot iterate (no forEach, size, etc.)
// Values are garbage collected when no other references exist
```

**WeakMap:**
```javascript
let weakMap = new WeakMap();

let key = { id: 1 };
weakMap.set(key, "value");
weakMap.get(key);       // "value"
weakMap.has(key);       // true
weakMap.delete(key);    // true

// Only object keys allowed
// Cannot iterate
```

**Use Cases:**
```javascript
// Private data
const privateData = new WeakMap();

class Person {
    constructor(name, secret) {
        privateData.set(this, { secret });
        this.name = name;
    }
    
    getSecret() {
        return privateData.get(this).secret;
    }
}

// Tracking objects without memory leaks
const visited = new WeakSet();

function process(node) {
    if (visited.has(node)) return;
    visited.add(node);
    // Process node...
}
// Nodes can be garbage collected when no longer referenced
```

## When to Use

Choosing the right data structure.

**Use Set When:**
```javascript
// Need unique values
let tags = new Set();
tags.add("javascript");
tags.add("tutorial");
tags.add("javascript");  // Ignored (duplicate)

// Fast membership testing
let allowedUsers = new Set(["alice", "bob"]);
if (allowedUsers.has(username)) { }

// Remove duplicates
let unique = [...new Set(array)];
```

**Use Map When:**
```javascript
// Need non-string keys
let cache = new Map();
cache.set(fetchOptions, response);

// Order matters
let orderedMap = new Map();  // Maintains insertion order

// Need key-value count
map.size;  // More efficient than Object.keys(obj).length

// Need to iterate in insertion order
for (let [k, v] of map) { }
```

**Object vs Map:**
```javascript
// Use Object for:
// - Simple key-value with string keys
// - JSON serialization needed
// - Prototype inheritance

// Use Map for:
// - Any key type (objects, functions)
// - Need size property
// - Frequent add/delete
// - Iteration order matters
// - No key collision with prototype
```

## Conversion

Convert between data types.

**Array ↔ Set:**
```javascript
// Array to Set
let arr = [1, 2, 3];
let set = new Set(arr);

// Set to Array
let back = [...set];
// or
let back2 = Array.from(set);
```

**Object ↔ Map:**
```javascript
// Object to Map
let obj = { a: 1, b: 2 };
let map = new Map(Object.entries(obj));

// Map to Object
let back = Object.fromEntries(map);
```

**Map ↔ Array:**
```javascript
// Array of pairs to Map
let pairs = [["a", 1], ["b", 2]];
let map = new Map(pairs);

// Map to Array of pairs
let back = [...map];
// or
let back2 = Array.from(map.entries());
```

**JSON Serialization:**
```javascript
// Maps don't serialize directly
let map = new Map([["a", 1]]);
JSON.stringify(map);  // "{}" - wrong!

// Convert first
JSON.stringify([...map]);  // '[["a",1]]'
JSON.stringify(Object.fromEntries(map));  // '{"a":1}'
```

## Summary / Key Takeaways

- **Set:** Collection of unique values; `add`, `has`, `delete`, `size`
- **Map:** Key-value pairs with any key type; `set`, `get`, `has`
- **Remove duplicates:** `[...new Set(array)]`
- **WeakSet/WeakMap:** Weak references; objects only; no iteration; allows GC
- **Use Set:** Unique values, fast lookup, set operations
- **Use Map:** Non-string keys, ordered entries, frequent modifications
- **Conversion:** `Object.entries()`, `Object.fromEntries()`, spread operator
- **Iteration:** Both maintain insertion order; use `for...of` or `forEach`

Sets and Maps provide specialized data structures for common programming patterns.
