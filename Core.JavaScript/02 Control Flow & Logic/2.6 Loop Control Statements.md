# **[[2.6 Loop Control Statements]]**

## Overview

This topic covers statements that control loop execution. You'll learn the break statement for exiting loops, continue statement for skipping iterations, labels for controlling nested loops, and patterns for early exit and iteration skipping.

## Break Statement

The `break` statement immediately exits the loop.

**Basic Break:**
```javascript
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;
    }
    console.log(i);
}
// Output: 0, 1, 2, 3, 4
```

**Search Pattern:**
```javascript
let numbers = [4, 8, 15, 16, 23, 42];
let target = 16;
let found = false;

for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] === target) {
        console.log("Found at index:", i);
        found = true;
        break;
    }
}

if (!found) {
    console.log("Not found");
}
```

**Break in While:**
```javascript
let input;

while (true) {
    input = prompt("Enter command (quit to exit):");
    
    if (input === "quit") {
        console.log("Goodbye!");
        break;
    }
    
    console.log("Processing:", input);
}
```

**First Match:**
```javascript
let users = [
    { name: "John", admin: false },
    { name: "Jane", admin: true },
    { name: "Bob", admin: true }
];

let firstAdmin;

for (let user of users) {
    if (user.admin) {
        firstAdmin = user;
        break;  // Stop at first admin
    }
}

console.log("First admin:", firstAdmin.name);  // "Jane"
```

## Continue Statement

The `continue` statement skips to the next iteration.

**Basic Continue:**
```javascript
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) {
        continue;  // Skip even numbers
    }
    console.log(i);
}
// Output: 1, 3, 5, 7, 9
```

**Skip Invalid Data:**
```javascript
let values = [1, null, 3, undefined, 5, NaN, 7];

for (let value of values) {
    if (value == null || isNaN(value)) {
        continue;  // Skip null, undefined, NaN
    }
    console.log("Valid:", value);
}
// Output: Valid: 1, Valid: 3, Valid: 5, Valid: 7
```

**Filter While Processing:**
```javascript
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let sum = 0;

for (let num of numbers) {
    if (num % 2 !== 0) {
        continue;  // Skip odd numbers
    }
    sum += num;  // Only sum evens
}

console.log("Sum of evens:", sum);  // 30
```

**Continue in While:**
```javascript
let i = 0;

while (i < 10) {
    i++;
    
    if (i % 3 === 0) {
        continue;  // Skip multiples of 3
    }
    
    console.log(i);
}
// Output: 1, 2, 4, 5, 7, 8, 10
```

## Labels

Labels name loops for targeted break and continue.

**Label Syntax:**
```javascript
labelName: for (...) {
    // Loop body
}
```

**Breaking Outer Loop:**
```javascript
outerLoop: for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        console.log(`(${i}, ${j})`);
        
        if (i === 2 && j === 2) {
            break outerLoop;  // Break entire outer loop
        }
    }
}
console.log("Done");
// Stops at (2, 2) and prints "Done"
```

**Without Label (Only Breaks Inner):**
```javascript
for (let i = 0; i < 5; i++) {
    for (let j = 0; j < 5; j++) {
        if (j === 2) {
            break;  // Only breaks inner loop
        }
        console.log(`(${i}, ${j})`);
    }
}
// Continues with next i after breaking inner loop
```

**Continue with Label:**
```javascript
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (j === 1) {
            continue outer;  // Skip to next outer iteration
        }
        console.log(`(${i}, ${j})`);
    }
}
// Output: (0, 0), (1, 0), (2, 0)
```

**Matrix Search:**
```javascript
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
let target = 5;

search: for (let row = 0; row < matrix.length; row++) {
    for (let col = 0; col < matrix[row].length; col++) {
        if (matrix[row][col] === target) {
            console.log(`Found at [${row}][${col}]`);
            break search;
        }
    }
}
```

## Nested Loop Control

Control flow in nested loops.

**Break Inner Only:**
```javascript
for (let i = 0; i < 3; i++) {
    console.log("Outer:", i);
    
    for (let j = 0; j < 5; j++) {
        if (j === 2) {
            break;  // Breaks inner loop only
        }
        console.log("  Inner:", j);
    }
}
// Outer loop continues after inner break
```

**Skip Specific Combinations:**
```javascript
for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
        if (i === j) {
            continue;  // Skip diagonal elements
        }
        console.log(`(${i}, ${j})`);
    }
}
```

**Multiple Labels:**
```javascript
outer: for (let i = 0; i < 3; i++) {
    middle: for (let j = 0; j < 3; j++) {
        for (let k = 0; k < 3; k++) {
            if (k === 1) {
                continue middle;  // Skip to next j
            }
            if (i + j + k > 3) {
                break outer;  // Exit all loops
            }
            console.log(i, j, k);
        }
    }
}
```

## Early Exit

Patterns for exiting loops efficiently.

**Return from Function:**
```javascript
function findIndex(array, target) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === target) {
            return i;  // Immediate exit with value
        }
    }
    return -1;  // Not found
}
```

**Boolean Flag:**
```javascript
let numbers = [1, 2, 3, 4, 5];
let hasEven = false;

for (let num of numbers) {
    if (num % 2 === 0) {
        hasEven = true;
        break;
    }
}

console.log("Has even:", hasEven);
```

**Accumulator with Early Exit:**
```javascript
function sumUntilNegative(numbers) {
    let sum = 0;
    
    for (let num of numbers) {
        if (num < 0) {
            break;  // Stop at first negative
        }
        sum += num;
    }
    
    return sum;
}

console.log(sumUntilNegative([1, 2, 3, -1, 4, 5]));  // 6
```

**Validation with Early Exit:**
```javascript
function validateAll(items) {
    for (let item of items) {
        if (!isValid(item)) {
            console.log("Invalid item:", item);
            return false;  // Fail fast
        }
    }
    return true;  // All valid
}
```

## Skip Iteration

Patterns for skipping iterations.

**Guard Clause Pattern:**
```javascript
for (let item of items) {
    // Skip conditions at the top
    if (!item) continue;
    if (!item.active) continue;
    if (item.deleted) continue;
    
    // Main processing
    processItem(item);
}
```

**Skip with Logging:**
```javascript
for (let user of users) {
    if (!user.email) {
        console.warn("Skipping user without email:", user.name);
        continue;
    }
    
    sendEmail(user.email);
}
```

**Conditional Processing:**
```javascript
for (let i = 1; i <= 20; i++) {
    // Skip numbers not divisible by both 2 and 3
    if (i % 2 !== 0 || i % 3 !== 0) {
        continue;
    }
    console.log("Divisible by 2 and 3:", i);
}
// Output: 6, 12, 18
```

**Error Tolerance:**
```javascript
let results = [];

for (let item of data) {
    try {
        let result = processItem(item);
        results.push(result);
    } catch (error) {
        console.error("Error processing:", item);
        continue;  // Skip failed item
    }
}
```

## Summary / Key Takeaways

- **break:** Immediately exits the current loop
- **continue:** Skips remaining code in current iteration, moves to next
- **Labels:** Name loops for targeted break/continue in nested loops
- **break with label:** Exits specified outer loop
- **continue with label:** Skips to next iteration of specified outer loop
- **Early exit:** Use return in functions, break with flag in loops
- **Guard clauses:** Use continue for clean skip conditions at top of loop
- **Best practice:** Avoid deeply nested loops; extract to functions when possible
- **Use labels sparingly:** They can make code harder to follow

Loop control statements provide precise control over iteration flow for complex processing scenarios.
