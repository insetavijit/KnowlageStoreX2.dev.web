# **[[1.5 Type Conversion]]**

## Overview

This topic covers how JavaScript handles type conversions. You'll learn about implicit coercion where JavaScript automatically converts types, explicit conversion using built-in functions, the Number(), String(), and Boolean() constructors, parsing functions parseInt and parseFloat, and truthy/falsy value evaluation.

## Implicit Coercion

JavaScript automatically converts types in certain situations—this is called implicit coercion or type coercion.

**String Coercion:**
```javascript
// + with string converts other operand to string
console.log("5" + 3);  // "53" (number → string)
console.log("Hello" + true);  // "Hellotrue"
console.log("Value: " + null);  // "Value: null"
console.log("" + 42);  // "42"

// Template literals also coerce to string
let num = 100;
console.log(`The number is ${num}`);  // "The number is 100"
```

**Number Coercion:**
```javascript
// Arithmetic operators (except +) convert to numbers
console.log("10" - 5);  // 5 (string → number)
console.log("10" * "2");  // 20
console.log("20" / "4");  // 5
console.log("15" % "4");  // 3

// Unary + converts to number
console.log(+"42");  // 42 (string → number)
console.log(+true);  // 1
console.log(+false);  // 0
console.log(+null);  // 0
console.log(+undefined);  // NaN
```

**Boolean Coercion:**
```javascript
// Logical context converts to boolean
if ("hello") {
    console.log("Non-empty strings are truthy");
}

if (0) {
    // Never runs (0 is falsy)
}

// Logical operators trigger coercion
console.log(!"");  // true (empty string is falsy)
console.log(!!"text");  // true (double NOT converts to boolean)
```

**Common Pitfalls:**
```javascript
// Mixed type comparisons
console.log("2" > "12");  // true (string comparison, lexicographic)
console.log("2" > 12);  // false (coerced to number)

// Array coercion
console.log([1, 2] + [3, 4]);  // "1,23,4"
console.log([] + []);  // "" (empty string)
console.log([] + {});  // "[object Object]"

// The infamous example
console.log(true + true);  // 2 (boolean → number)
console.log(true + "1");  // "true1" (boolean → string)
```

## Explicit Conversion

Explicitly convert types using built-in functions for predictable, readable code.

**To String:**
```javascript
// String() function
console.log(String(42));  // "42"
console.log(String(true));  // "true"
console.log(String(null));  // "null"

// .toString() method
let num = 123;
console.log(num.toString());  // "123"
console.log((10).toString(2));  // "1010" (binary)
console.log((255).toString(16));  // "ff" (hexadecimal)
```

**To Number:**
```javascript
// Number() function
console.log(Number("42"));  // 42
console.log(Number("3.14"));  // 3.14
console.log(Number(true));  // 1
console.log(Number(false));  // 0
console.log(Number(null));  // 0
console.log(Number(undefined));  // NaN
console.log(Number("hello"));  // NaN
console.log(Number(""));  // 0 (empty string → 0)
```

**To Boolean:**
```javascript
// Boolean() function
console.log(Boolean(1));  // true
console.log(Boolean(0));  // false
console.log(Boolean("text"));  // true
console.log(Boolean(""));  // false
console.log(Boolean(null));  // false
console.log(Boolean(undefined));  // false
console.log(Boolean({}));  // true (objects are truthy)
console.log(Boolean([]));  // true (arrays are truthy)
```

## Number(), String(), Boolean()

These constructor functions convert values to their respective types.

**Number() Details:**
```javascript
// Handles various formats
console.log(Number("  42  "));  // 42 (trims whitespace)
console.log(Number("12.5px"));  // NaN (stops at non-digit)
console.log(Number("0xFF"));  // 255 (hexadecimal)

// Special cases
console.log(Number(true));  // 1
console.log(Number(false));  // 0
console.log(Number(null));  // 0
console.log(Number(undefined));  // NaN
```

**String() Details:**
```javascript
// Always succeeds (everything can be string)
console.log(String(0));  // "0"
console.log(String(-10.5));  // "-10.5"
console.log(String(true));  // "true"
console.log(String(null));  // "null"
console.log(String(undefined));  // "undefined"
console.log(String([1, 2, 3]));  // "1,2,3"
console.log(String({a: 1}));  // "[object Object]"
```

**Boolean() Details:**
```javascript
// Falsy values → false
console.log(Boolean(0));  // false
console.log(Boolean(""));  // false
console.log(Boolean(null));  // false
console.log(Boolean(undefined));  // false
console.log(Boolean(NaN));  // false
console.log(Boolean(false));  // false

// Everything else → true
console.log(Boolean(1));  // true
console.log(Boolean("0"));  // true (non-empty string!)
console.log(Boolean("false"));  // true (string, not boolean)
console.log(Boolean([]));  // true
console.log(Boolean({}));  // true
```

## parseInt and parseFloat

Parse strings into numbers with more flexibility than Number().

**parseInt():**
```javascript
// Parses integer, stops at first non-digit
console.log(parseInt("42"));  // 42
console.log(parseInt("42px"));  // 42 (ignores "px")
console.log(parseInt("  100  "));  // 100 (trims whitespace)
console.log(parseInt("3.14"));  // 3 (stops at decimal)

// Specify radix (base) for parsing
console.log(parseInt("1010", 2));  // 10 (binary)
console.log(parseInt("FF", 16));  // 255 (hexadecimal)
console.log(parseInt("77", 8));  // 63 (octal)

// Always specify radix to avoid confusion
console.log(parseInt("010", 10));  // 10 (decimal)

// Edge cases
console.log(parseInt("hello"));  // NaN
console.log(parseInt(""));  // NaN (empty string)
```

**parseFloat():**
```javascript
// Parses floating-point number
console.log(parseFloat("3.14"));  // 3.14
console.log(parseFloat("3.14px"));  // 3.14 (ignores "px")
console.log(parseFloat("  2.5  "));  // 2.5
console.log(parseFloat("10"));  // 10

// Only parses decimal (no radix parameter)
console.log(parseFloat("0xFF"));  // 0 (stops at 'x')

// Multiple decimals
console.log(parseFloat("3.14.159"));  // 3.14 (stops at second dot)
```

**Number() vs parseInt/parseFloat:**
```javascript
// Number() requires valid number string
console.log(Number("42px"));  // NaN

// parseInt/parseFloat are more lenient
console.log(parseInt("42px"));  // 42
console.log(parseFloat("42.5px"));  // 42.5

// Number() handles empty string differently
console.log(Number(""));  // 0
console.log(parseInt(""));  // NaN
console.log(parseFloat(""));  // NaN
```

## Truthy and Falsy Values

JavaScript evaluates all values as either truthy or falsy in boolean contexts.

**Falsy Values (only 6):**
```javascript
// false - the boolean false
if (false) { /* never runs */ }

// 0 - the number zero
if (0) { /* never runs */ }

// "" - empty string
if ("") { /* never runs */ }

// null - intentional absence
if (null) { /* never runs */ }

// undefined - uninitialized
if (undefined) { /* never runs */ }

// NaN - not-a-number
if (NaN) { /* never runs */ }
```

**Truthy Values (everything else):**
```javascript
// All numbers except 0
if (1) { /* runs */ }
if (-1) { /* runs */ }
if (3.14) { /* runs */ }

// All strings except ""
if ("hello") { /* runs */ }
if ("0") { /* runs - string, not number! */ }
if ("false") { /* runs - string, not boolean! */ }
if (" ") { /* runs - whitespace string */ }

// Objects and arrays (even if empty)
if ({}) { /* runs */ }
if ([]) { /* runs */ }

// Functions
if (function(){}) { /* runs */ }
```

**Practical Use Cases:**
```javascript
// Default values with ||
function greet(name) {
    name = name || "Guest";  // Use "Guest" if name is falsy
    console.log(`Hello, ${name}`);
}
greet("");  // "Hello, Guest"
greet("Alice");  // "Hello, Alice"

// Guard clauses
function processData(data) {
    if (!data) {
        console.log("No data provided");
        return;
    }
    // Process data...
}

// Conditional rendering
let message = isLoggedIn && "Welcome back!";

// Be careful with 0 and ""
let count = 0;
if (!count) {
    // Runs even though 0 is a valid count!
}
// Better:
if (count === undefined || count === null) {
    // Only runs for missing values
}
```

**Common Mistakes:**
```javascript
// String numbers are truthy
if ("0") {
    console.log("Truthy!");  // Runs! "0" is a non-empty string
}

// Empty array/object are truthy
if ([]) {
    console.log("Truthy!");  // Runs!
}

// Use explicit checks when needed
let arr = [];
if (arr.length > 0) {  // Better than if (arr)
    console.log("Array has elements");
}
```

## Summary / Key Takeaways

- **Implicit coercion:** JavaScript automatically converts types; `+` with string converts to string, other operators convert to number
- **Explicit conversion:** Use `String()`, `Number()`, `Boolean()` for clear, intentional conversions
- **Number():** Converts entire string; returns `NaN` for invalid numbers; `null → 0`, `undefined → NaN`
- **String():** Always succeeds; converts any value to string representation
- **Boolean():** Converts to `true` or `false` based on truthy/falsy evaluation
- **parseInt/parseFloat:** Parse numbers from strings; ignore trailing non-digits; always specify radix for `parseInt`
- **Falsy values (6 only):** `false`, `0`, `""`, `null`, `undefined`, `NaN`
- **Truthy values:** Everything else, including `"0"`, `"false"`, `[]`, `{}`
- **Best practice:** Use explicit conversion for clarity; understand truthiness for conditional logic

Understanding type conversion prevents bugs and makes JavaScript code more predictable and maintainable.
