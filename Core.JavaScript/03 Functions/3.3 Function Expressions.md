# **[[3.3 Function Expressions]]**

## Overview

This topic covers function expressions as an alternative to declarations. You'll learn function expression syntax, anonymous functions, named function expressions, assigning functions to variables, and the differences between expressions and declarations.

## Function Expressions

A function expression assigns a function to a variable.

**Syntax:**
```javascript
const functionName = function(parameters) {
    // Function body
};
```

**Basic Example:**
```javascript
const greet = function(name) {
    console.log("Hello, " + name);
};

greet("Alice");  // "Hello, Alice"
```

**Comparison with Declaration:**
```javascript
// Function Declaration
function add(a, b) {
    return a + b;
}

// Function Expression
const subtract = function(a, b) {
    return a - b;
};

// Both called the same way
add(5, 3);       // 8
subtract(5, 3);  // 2
```

**Storing in Objects:**
```javascript
const calculator = {
    add: function(a, b) { return a + b; },
    subtract: function(a, b) { return a - b; }
};

calculator.add(10, 5);  // 15
```

## Anonymous Functions

Functions without a name.

**Function Expression (Anonymous):**
```javascript
const greet = function(name) {
    console.log("Hello, " + name);
};
// The function itself has no name; variable holds the reference
```

**Callbacks:**
```javascript
// Anonymous function as callback
setTimeout(function() {
    console.log("Executed after 1 second");
}, 1000);

// Array methods
[1, 2, 3].forEach(function(num) {
    console.log(num * 2);
});

// Event handlers
button.addEventListener('click', function(event) {
    console.log("Button clicked");
});
```

**Immediately Invoked:**
```javascript
// IIFE - Immediately Invoked Function Expression
(function() {
    console.log("Executed immediately");
})();

// With parameters
(function(name) {
    console.log("Hello, " + name);
})("World");
```

## Named Function Expressions

Function expressions can have an optional name.

**Syntax:**
```javascript
const factorial = function fact(n) {
    if (n <= 1) return 1;
    return n * fact(n - 1);  // Name available inside
};

factorial(5);  // 120
// fact(5);    // Error: fact is not defined (outside)
```

**Benefits:**
```javascript
// 1. Self-reference (recursion)
const fib = function fibonacci(n) {
    if (n < 2) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
};

// 2. Better stack traces for debugging
const processData = function processData(data) {
    // 'processData' appears in error stack traces
};

// 3. Clearer intention
const handler = function onButtonClick(event) {
    // Name describes purpose
};
```

**Name is Local:**
```javascript
const outer = function inner() {
    console.log(typeof inner);    // "function"
    console.log(typeof outer);    // "function"
};

outer();
console.log(typeof inner);  // "undefined" (not accessible)
console.log(typeof outer);  // "function"
```

## Assigning Functions

Functions as first-class values.

**Variable Assignment:**
```javascript
const sayHello = function() {
    console.log("Hello");
};

// Reassign (if using let)
let greet = function() {
    console.log("Hi");
};

greet = function() {
    console.log("Hey");  // Reassigned
};
```

**Passing as Arguments:**
```javascript
function execute(callback) {
    console.log("Before");
    callback();
    console.log("After");
}

execute(function() {
    console.log("Callback executed");
});
// Before → Callback executed → After
```

**Returning Functions:**
```javascript
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

double(5);  // 10
triple(5);  // 15
```

**Array of Functions:**
```javascript
const operations = [
    function(x) { return x + 1; },
    function(x) { return x * 2; },
    function(x) { return x ** 2; }
];

let value = 3;
for (let op of operations) {
    value = op(value);
}
console.log(value);  // ((3 + 1) * 2) ** 2 = 64
```

## Expression vs Declaration

Key differences between the two forms.

**Hoisting:**
```javascript
// Declaration: Hoisted (can call before definition)
sayHello();  // Works!
function sayHello() {
    console.log("Hello");
}

// Expression: Not hoisted
// sayGoodbye();  // Error: Cannot access before initialization
const sayGoodbye = function() {
    console.log("Goodbye");
};
```

**Conditional Definition:**
```javascript
// Expression: Can be conditional
let greet;
if (language === "es") {
    greet = function() { console.log("Hola"); };
} else {
    greet = function() { console.log("Hello"); };
}

// Declaration: Hoisting can cause issues
// if (language === "es") {
//     function greet() { console.log("Hola"); }  // Problematic
// }
```

**Block Scope:**
```javascript
// Expression with const/let: Block scoped
{
    const inner = function() { console.log("inner"); };
    inner();  // Works
}
// inner();  // Error: inner is not defined

// Declaration: Function-scoped (may leak in some engines)
```

**When to Use Each:**
```javascript
// Use Declaration:
// - Named, reusable functions
// - When hoisting is helpful
function processOrder(order) { ... }

// Use Expression:
// - Callbacks and event handlers
// - Conditional assignment
// - When you want to prevent hoisting
const handler = function(event) { ... };
```

## Summary / Key Takeaways

- **Function expression:** Assigns function to variable: `const fn = function() {}`
- **Anonymous functions:** No name; common in callbacks and IIFE
- **Named expressions:** Have internal name for recursion and debugging
- **First-class functions:** Can assign, pass, return, store in arrays/objects
- **Hoisting difference:** Declarations hoisted; expressions not hoisted
- **Block scope:** Expressions with const/let are block-scoped
- **Use cases:** Expressions for callbacks, conditional assignment, preventing hoisting
- **Named expressions:** Better stack traces, self-reference capability

Function expressions provide flexibility for dynamic function creation and assignment.
