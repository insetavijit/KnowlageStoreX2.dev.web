# **[[3.4 Arrow Functions]]**

## Overview

This topic covers ES6 arrow functions. You'll learn arrow function syntax, implicit return for concise expressions, the difference in `this` binding, when to use arrow functions, and their limitations.

## Arrow Function Syntax

Arrow functions provide concise syntax for function expressions.

**Basic Syntax:**
```javascript
// Traditional function expression
const add = function(a, b) {
    return a + b;
};

// Arrow function
const addArrow = (a, b) => {
    return a + b;
};
```

**Parameter Variations:**
```javascript
// No parameters: empty parentheses
const greet = () => {
    console.log("Hello!");
};

// Single parameter: parentheses optional
const square = x => {
    return x * x;
};

// Multiple parameters: parentheses required
const multiply = (a, b) => {
    return a * b;
};
```

**Concise Body:**
```javascript
// Single expression: implicit return
const double = x => x * 2;
const sum = (a, b) => a + b;
const isEven = n => n % 2 === 0;

// Equivalent to
const doubleVerbose = x => { return x * 2; };
```

## Implicit Return

Arrow functions return automatically without braces.

**Simple Return:**
```javascript
// Implicit return (no braces, no return keyword)
const add = (a, b) => a + b;
const greet = name => `Hello, ${name}!`;
const multiply = (x, y) => x * y;

add(2, 3);       // 5
greet("Alice");  // "Hello, Alice!"
```

**Returning Objects:**
```javascript
// Wrap object in parentheses
const createUser = (name, age) => ({ name, age });

createUser("John", 30);  // { name: "John", age: 30 }

// Without parentheses: braces = function body
// const broken = () => { name: "John" };  // Returns undefined!
```

**Multi-line with Braces:**
```javascript
// Braces require explicit return
const process = (data) => {
    let result = data.trim();
    result = result.toLowerCase();
    return result;  // Must include return
};
```

**Expression vs Statement:**
```javascript
// Expression: implicit return works
const isPositive = n => n > 0;

// Statement: need braces and return
const calculate = (a, b, op) => {
    if (op === '+') return a + b;
    if (op === '-') return a - b;
    return 0;
};
```

## No Binding of this

Arrow functions don't have their own `this`—they inherit from the enclosing scope.

**Problem with Regular Functions:**
```javascript
const person = {
    name: "John",
    friends: ["Alice", "Bob"],
    
    greetFriends: function() {
        this.friends.forEach(function(friend) {
            console.log(this.name + " says hi to " + friend);
            // this.name is undefined! 'this' is lost
        });
    }
};
```

**Solution with Arrow Functions:**
```javascript
const person = {
    name: "John",
    friends: ["Alice", "Bob"],
    
    greetFriends: function() {
        this.friends.forEach(friend => {
            console.log(this.name + " says hi to " + friend);
            // Works! Arrow inherits 'this' from greetFriends
        });
    }
};

person.greetFriends();
// "John says hi to Alice"
// "John says hi to Bob"
```

**In Event Handlers:**
```javascript
class Counter {
    constructor() {
        this.count = 0;
    }
    
    // Arrow function preserves 'this'
    increment = () => {
        this.count++;
        console.log(this.count);
    }
}

const counter = new Counter();
button.addEventListener('click', counter.increment);  // Works!
```

**Lexical this:**
```javascript
function Timer() {
    this.seconds = 0;
    
    // Arrow function captures 'this' from Timer
    setInterval(() => {
        this.seconds++;
        console.log(this.seconds);
    }, 1000);
}

new Timer();  // Logs 1, 2, 3, ...
```

## When to Use Arrows

Appropriate and inappropriate use cases.

**✓ Use Arrow Functions:**
```javascript
// Callbacks
array.map(x => x * 2);
array.filter(x => x > 0);
array.reduce((sum, x) => sum + x, 0);

// Promises
fetch(url)
    .then(response => response.json())
    .then(data => console.log(data));

// Short function expressions
const getArea = (w, h) => w * h;
const isValid = x => x != null;

// Preserving 'this' in methods
class App {
    handleClick = () => {
        this.update();
    }
}
```

**✗ Avoid Arrow Functions:**
```javascript
// Object methods (this won't work as expected)
const obj = {
    name: "Object",
    // Bad: arrow function has no 'this'
    getName: () => this.name  // undefined!
};

// Use regular method instead
const objGood = {
    name: "Object",
    getName() {
        return this.name;  // Works
    }
};

// Prototype methods
function Person(name) {
    this.name = name;
}
// Bad
Person.prototype.greet = () => {
    console.log(this.name);  // Won't work
};

// Constructors (cannot be used with 'new')
// const Person = (name) => { this.name = name; };
// new Person("John");  // Error!
```

## Concise Syntax

Arrow functions at their most compact.

**One-liner Functions:**
```javascript
// Array methods
const doubled = [1, 2, 3].map(n => n * 2);
const evens = [1, 2, 3, 4].filter(n => n % 2 === 0);
const sum = [1, 2, 3].reduce((a, b) => a + b, 0);

// Sorting
const sorted = names.sort((a, b) => a.localeCompare(b));

// Conditional logic
const max = (a, b) => a > b ? a : b;
```

**Chaining:**
```javascript
const result = [1, 2, 3, 4, 5]
    .filter(n => n % 2 === 0)
    .map(n => n * 10)
    .reduce((sum, n) => sum + n, 0);
// 60
```

**Event Handlers:**
```javascript
button.addEventListener('click', () => console.log('Clicked!'));
input.addEventListener('input', e => handleInput(e.target.value));
```

## Limitations

What arrow functions cannot do.

**No `arguments` Object:**
```javascript
// Regular function has arguments
function regular() {
    console.log(arguments);  // Works
}

// Arrow function doesn't
const arrow = () => {
    // console.log(arguments);  // Error!
};

// Use rest parameters instead
const arrowRest = (...args) => {
    console.log(args);  // Works
};
```

**Cannot Use as Constructor:**
```javascript
const Person = (name) => {
    this.name = name;
};

// new Person("John");  // TypeError
```

**No `prototype` Property:**
```javascript
const arrow = () => {};
console.log(arrow.prototype);  // undefined

function regular() {}
console.log(regular.prototype);  // {}
```

**Cannot Change `this`:**
```javascript
const arrow = () => this;

// call, apply, bind don't change arrow's 'this'
arrow.call({ a: 1 });   // Still original 'this'
arrow.apply({ a: 1 });  // Still original 'this'
arrow.bind({ a: 1 })(); // Still original 'this'
```

## Summary / Key Takeaways

- **Syntax:** `(params) => expression` or `(params) => { statements }`
- **Implicit return:** Single expression returns automatically without braces
- **Return objects:** Wrap in parentheses: `() => ({ key: value })`
- **No own `this`:** Inherits from enclosing scope (lexical this)
- **Best for:** Callbacks, array methods, preserving `this` in methods
- **Avoid for:** Object methods, prototype methods, constructors
- **No `arguments`:** Use rest parameters instead: `(...args)`
- **Cannot use `new`:** Arrow functions aren't constructors

Arrow functions provide concise syntax and solve common `this` binding issues in JavaScript.
