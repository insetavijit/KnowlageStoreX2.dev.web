# **[[3.5 Scope]]**

## Overview

This topic covers variable scope in JavaScript. You'll learn global scope, function scope, block scope with let/const, lexical scope, the scope chain, and variable shadowing.

## Global Scope

Variables accessible everywhere in the program.

**Global Variables:**
```javascript
// Declared outside any function or block
var globalVar = "I'm global";
let globalLet = "Also global";
const GLOBAL_CONST = "Global constant";

function test() {
    console.log(globalVar);    // Accessible
    console.log(globalLet);    // Accessible
    console.log(GLOBAL_CONST); // Accessible
}
```

**Implicit Globals (Avoid!):**
```javascript
function createGlobal() {
    implicitGlobal = "Oops!";  // No var/let/const = global!
}

createGlobal();
console.log(implicitGlobal);  // "Oops!" - accessible globally

// Use strict mode to prevent
"use strict";
function strict() {
    // implicitGlobal = "Error!";  // ReferenceError
}
```

**Window/Global Object:**
```javascript
// Browser: global variables attach to window
var browserGlobal = "attached";
console.log(window.browserGlobal);  // "attached"

// let/const don't attach to window
let notAttached = "not on window";
console.log(window.notAttached);  // undefined
```

## Function Scope

Variables declared inside a function are local to that function.

**Function-Scoped Variables:**
```javascript
function example() {
    var localVar = "I'm local";
    let localLet = "Also local";
    const LOCAL_CONST = "Local constant";
    
    console.log(localVar);  // Accessible inside
}

example();
// console.log(localVar);  // Error: not defined
```

**Parameters Are Local:**
```javascript
function greet(name) {
    // 'name' is local to this function
    console.log("Hello, " + name);
}

greet("Alice");
// console.log(name);  // Error: name is not defined
```

**var Is Function-Scoped:**
```javascript
function test() {
    if (true) {
        var x = 10;  // Function-scoped, not block-scoped
    }
    console.log(x);  // 10 - accessible!
}

test();
```

**Each Call Has Own Scope:**
```javascript
function counter() {
    var count = 0;
    count++;
    return count;
}

counter();  // 1
counter();  // 1 (fresh scope each call)
counter();  // 1
```

## Block Scope

let and const are limited to their enclosing block.

**Block-Scoped Variables:**
```javascript
if (true) {
    let blockLet = "block";
    const BLOCK_CONST = "block";
    var notBlocked = "function-scoped";
}

// console.log(blockLet);     // Error: not defined
// console.log(BLOCK_CONST);  // Error: not defined
console.log(notBlocked);      // "function-scoped"
```

**Loops and Block Scope:**
```javascript
for (let i = 0; i < 3; i++) {
    console.log(i);  // 0, 1, 2
}
// console.log(i);  // Error: i is not defined

for (var j = 0; j < 3; j++) {
    console.log(j);  // 0, 1, 2
}
console.log(j);  // 3 - leaked out!
```

**Closure with let vs var:**
```javascript
// Problem with var
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);  // 3, 3, 3 (all same!)
    }, 100);
}

// Solution with let
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);  // 0, 1, 2 (correct!)
    }, 100);
}
```

## Lexical Scope

Functions can access variables from their definition context.

**Nested Function Access:**
```javascript
function outer() {
    let outerVar = "outer";
    
    function inner() {
        let innerVar = "inner";
        console.log(outerVar);  // Accessible
        console.log(innerVar);  // Accessible
    }
    
    inner();
    // console.log(innerVar);  // Error: not accessible
}
```

**Determined at Definition:**
```javascript
let x = "global";

function outer() {
    let x = "outer";
    
    function inner() {
        console.log(x);  // "outer" (not global)
    }
    
    return inner;
}

let fn = outer();
fn();  // "outer" - uses scope where defined
```

**Not Affected by Call Location:**
```javascript
function createGreeter(greeting) {
    return function(name) {
        console.log(greeting + ", " + name);
    };
}

let greet = createGreeter("Hello");
greet("World");  // "Hello, World"
// greeting is captured from definition scope
```

## Scope Chain

JavaScript looks up variables through the scope chain.

**Lookup Process:**
```javascript
let global = "global";

function outer() {
    let outer = "outer";
    
    function inner() {
        let inner = "inner";
        
        console.log(inner);   // Found in inner scope
        console.log(outer);   // Found in outer scope
        console.log(global);  // Found in global scope
    }
    
    inner();
}

outer();
```

**First Match Wins:**
```javascript
let name = "global";

function outer() {
    let name = "outer";
    
    function inner() {
        let name = "inner";
        console.log(name);  // "inner" (innermost wins)
    }
    
    inner();
}

outer();
```

**Undefined vs Error:**
```javascript
let defined = "exists";

function test() {
    console.log(defined);     // "exists" (found in chain)
    // console.log(notDefined);  // ReferenceError (not in chain)
}
```

## Variable Shadowing

Inner scope variables hide outer scope variables with same name.

**Shadowing Example:**
```javascript
let x = "global";

function outer() {
    let x = "outer";  // Shadows global x
    console.log(x);   // "outer"
    
    function inner() {
        let x = "inner";  // Shadows outer x
        console.log(x);   // "inner"
    }
    
    inner();
}

outer();
console.log(x);  // "global" (original unchanged)
```

**Intentional Shadowing:**
```javascript
function process(items) {
    // 'items' shadows any global 'items'
    for (let item of items) {
        // 'item' is local to loop
        console.log(item);
    }
}
```

**Accidental Shadowing (Avoid):**
```javascript
let data = "important";

function bad() {
    let data = "local";  // Accidentally shadows!
    // Original 'data' is now inaccessible
}

// Choose distinct names
function good(inputData) {
    let processedData = transform(inputData);
    // Clear, distinct names
}
```

**const in Blocks:**
```javascript
const CONFIG = "global";

if (true) {
    const CONFIG = "block";  // Shadows, doesn't modify
    console.log(CONFIG);      // "block"
}

console.log(CONFIG);  // "global" (unchanged)
```

## Summary / Key Takeaways

- **Global scope:** Variables outside functions/blocks; accessible everywhere
- **Function scope:** Variables inside functions; not accessible outside
- **Block scope:** let/const are block-scoped; var is not
- **Lexical scope:** Functions access variables from where they're defined
- **Scope chain:** Variable lookup proceeds from inner to outer to global
- **Shadowing:** Inner variables with same name hide outer ones
- **Best practices:** Use let/const, avoid global variables, choose distinct names
- **var quirks:** Function-scoped, hoisted, attaches to window

Understanding scope is essential for managing variable visibility and avoiding naming conflicts.
