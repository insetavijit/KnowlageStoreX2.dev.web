# **[[3.7 Higher-Order Functions]]**

## Overview

This topic covers higher-order functions. You'll learn to pass functions as arguments, return functions from functions, work with callbacks, compose functions, and apply functional programming basics.

## Functions as Arguments

Functions can be passed to other functions.

**Basic Callback:**
```javascript
function greet(name, formatter) {
    return formatter(name);
}

function uppercase(str) {
    return str.toUpperCase();
}

function addGreeting(str) {
    return "Hello, " + str;
}

greet("alice", uppercase);      // "ALICE"
greet("bob", addGreeting);      // "Hello, bob"
```

**Array Methods:**
```javascript
const numbers = [1, 2, 3, 4, 5];

// map: transform each element
const doubled = numbers.map(function(n) {
    return n * 2;
});  // [2, 4, 6, 8, 10]

// filter: keep elements passing test
const evens = numbers.filter(function(n) {
    return n % 2 === 0;
});  // [2, 4]

// reduce: combine into single value
const sum = numbers.reduce(function(acc, n) {
    return acc + n;
}, 0);  // 15
```

**Custom Higher-Order Function:**
```javascript
function repeat(n, action) {
    for (let i = 0; i < n; i++) {
        action(i);
    }
}

repeat(3, console.log);       // 0, 1, 2
repeat(3, i => console.log(i * 10));  // 0, 10, 20
```

## Returning Functions

Functions can return other functions.

**Function Factory:**
```javascript
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

double(5);  // 10
triple(5);  // 15
```

**Configurable Functions:**
```javascript
function createValidator(min, max) {
    return function(value) {
        return value >= min && value <= max;
    };
}

const isValidAge = createValidator(0, 120);
const isValidScore = createValidator(0, 100);

isValidAge(25);    // true
isValidScore(150); // false
```

**Partial Application:**
```javascript
function add(a, b) {
    return a + b;
}

function partial(fn, firstArg) {
    return function(secondArg) {
        return fn(firstArg, secondArg);
    };
}

const add5 = partial(add, 5);
add5(3);  // 8
add5(10); // 15
```

## Callbacks

Functions passed to be called later.

**Synchronous Callbacks:**
```javascript
function process(items, callback) {
    const results = [];
    for (let item of items) {
        results.push(callback(item));
    }
    return results;
}

process([1, 2, 3], n => n * 2);  // [2, 4, 6]
```

**Asynchronous Callbacks:**
```javascript
function fetchData(callback) {
    setTimeout(function() {
        callback({ data: "result" });
    }, 1000);
}

fetchData(function(result) {
    console.log(result);  // After 1 second: { data: "result" }
});
```

**Event Callbacks:**
```javascript
button.addEventListener('click', function(event) {
    console.log("Clicked!", event.target);
});

// Named callback
function handleClick(event) {
    console.log("Clicked!");
}
button.addEventListener('click', handleClick);
```

**Error-First Callbacks:**
```javascript
function readFile(path, callback) {
    // Simulating async file read
    setTimeout(() => {
        if (path === "notfound") {
            callback(new Error("File not found"), null);
        } else {
            callback(null, "file contents");
        }
    }, 100);
}

readFile("myfile.txt", (error, data) => {
    if (error) {
        console.error(error.message);
        return;
    }
    console.log(data);
});
```

## Function Composition

Combining simple functions into complex ones.

**Manual Composition:**
```javascript
function addOne(x) { return x + 1; }
function double(x) { return x * 2; }
function square(x) { return x * x; }

// Compose manually
const result = square(double(addOne(5)));  // 144
```

**Compose Function:**
```javascript
function compose(...fns) {
    return function(x) {
        return fns.reduceRight((acc, fn) => fn(acc), x);
    };
}

const transform = compose(square, double, addOne);
transform(5);  // 144 (same as square(double(addOne(5))))
```

**Pipe Function:**
```javascript
function pipe(...fns) {
    return function(x) {
        return fns.reduce((acc, fn) => fn(acc), x);
    };
}

const process = pipe(addOne, double, square);
process(5);  // 144 (reads left-to-right: (5+1)*2)^2
```

**Practical Composition:**
```javascript
const trim = s => s.trim();
const lowercase = s => s.toLowerCase();
const split = s => s.split(' ');

const processInput = pipe(trim, lowercase, split);
processInput("  Hello WORLD  ");  // ["hello", "world"]
```

## Functional Programming Basics

Core FP concepts in JavaScript.

**Pure Functions:**
```javascript
// Pure: same input â†’ same output, no side effects
function add(a, b) {
    return a + b;
}

// Impure: modifies external state
let total = 0;
function addToTotal(n) {
    total += n;  // Side effect!
    return total;
}
```

**Immutability:**
```javascript
// Avoid mutating data
const numbers = [1, 2, 3];

// Bad: mutates original
numbers.push(4);

// Good: creates new array
const newNumbers = [...numbers, 4];
```

**Map, Filter, Reduce:**
```javascript
const users = [
    { name: "Alice", age: 25 },
    { name: "Bob", age: 17 },
    { name: "Charlie", age: 30 }
];

// Chain operations
const adultNames = users
    .filter(user => user.age >= 18)
    .map(user => user.name);
// ["Alice", "Charlie"]

// Reduce to object
const byName = users.reduce((acc, user) => {
    acc[user.name] = user;
    return acc;
}, {});
```

**Function Chaining:**
```javascript
class Chain {
    constructor(value) {
        this.value = value;
    }
    
    map(fn) {
        return new Chain(fn(this.value));
    }
    
    filter(fn) {
        return new Chain(fn(this.value) ? this.value : null);
    }
    
    get() {
        return this.value;
    }
}

new Chain(5)
    .map(x => x * 2)
    .map(x => x + 1)
    .get();  // 11
```

## Summary / Key Takeaways

- **Higher-order function:** Takes functions as arguments or returns functions
- **Functions as arguments:** Callbacks, array methods (map, filter, reduce)
- **Returning functions:** Factories, partial application, closures
- **Callbacks:** Functions called later, sync or async, error-first pattern
- **Composition:** Combine simple functions into complex pipelines
- **compose:** Right-to-left execution; **pipe:** Left-to-right execution
- **Functional programming:** Pure functions, immutability, declarative code
- **Benefits:** Reusability, testability, maintainability

Higher-order functions are central to JavaScript's expressive power and functional programming capabilities.
