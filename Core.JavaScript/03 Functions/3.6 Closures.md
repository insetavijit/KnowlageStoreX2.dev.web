# **[[3.6 Closures]]**

## Overview

This topic covers closures, a fundamental JavaScript concept. You'll learn what closures are, how they capture the lexical environment, creating private variables, common use cases, and memory considerations.

## Closure Concept

A closure is a function that remembers its lexical scope even when executed outside that scope.

**Basic Example:**
```javascript
function outer() {
    let message = "Hello";
    
    function inner() {
        console.log(message);  // Accesses outer's variable
    }
    
    return inner;
}

let greet = outer();  // outer() returns inner function
greet();  // "Hello" - still has access to 'message'!
```

**The Closure:**
```javascript
// The inner function "closes over" the outer function's variables
function createCounter() {
    let count = 0;  // Private to this closure
    
    return function() {
        count++;
        return count;
    };
}

let counter = createCounter();
counter();  // 1
counter();  // 2
counter();  // 3
// 'count' persists between calls
```

**Multiple Closures:**
```javascript
function createGreeter(greeting) {
    return function(name) {
        return greeting + ", " + name;
    };
}

let sayHello = createGreeter("Hello");
let sayHi = createGreeter("Hi");

sayHello("Alice");  // "Hello, Alice"
sayHi("Bob");       // "Hi, Bob"
// Each closure has its own 'greeting'
```

## Lexical Environment

Closures capture the environment where they're defined.

**Capturing Variables:**
```javascript
function outer() {
    let x = 10;
    
    return function() {
        return x;  // Captured at definition time
    };
}

let fn = outer();
console.log(fn());  // 10
```

**Live Binding:**
```javascript
function counter() {
    let count = 0;
    
    return {
        increment: function() { count++; },
        decrement: function() { count--; },
        get: function() { return count; }
    };
}

let c = counter();
c.increment();
c.increment();
console.log(c.get());  // 2
c.decrement();
console.log(c.get());  // 1
// All methods share the same 'count'
```

**Captured by Reference:**
```javascript
function create() {
    let items = [];
    
    return {
        add: (item) => items.push(item),
        getAll: () => items
    };
}

let list = create();
list.add("a");
list.add("b");
console.log(list.getAll());  // ["a", "b"]
```

## Private Variables

Closures enable data encapsulation.

**Public/Private Pattern:**
```javascript
function createPerson(name) {
    // Private variable
    let _age = 0;
    
    return {
        // Public methods
        getName: () => name,
        getAge: () => _age,
        setAge: (age) => {
            if (age >= 0) _age = age;
        },
        birthday: () => {
            _age++;
            console.log(`Happy ${_age}th birthday, ${name}!`);
        }
    };
}

let person = createPerson("Alice");
person.setAge(25);
person.birthday();   // "Happy 26th birthday, Alice!"
person.getAge();     // 26
// person._age       // undefined (truly private)
```

**Module Pattern:**
```javascript
const calculator = (function() {
    // Private state
    let result = 0;
    let history = [];
    
    // Private function
    function log(operation) {
        history.push({ operation, result });
    }
    
    // Public API
    return {
        add(n) {
            result += n;
            log(`+${n}`);
            return this;
        },
        subtract(n) {
            result -= n;
            log(`-${n}`);
            return this;
        },
        getResult() {
            return result;
        },
        getHistory() {
            return [...history];  // Return copy
        },
        reset() {
            result = 0;
            history = [];
            return this;
        }
    };
})();

calculator.add(5).add(3).subtract(2);
calculator.getResult();  // 6
```

## Closure Use Cases

Practical applications of closures.

**Factory Functions:**
```javascript
function createMultiplier(factor) {
    return (number) => number * factor;
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

double(5);  // 10
triple(5);  // 15
```

**Event Handlers:**
```javascript
function setupButton(buttonId, message) {
    document.getElementById(buttonId).addEventListener('click', () => {
        alert(message);  // 'message' is captured
    });
}

setupButton('btn1', 'Hello!');
setupButton('btn2', 'Goodbye!');
```

**Debounce/Throttle:**
```javascript
function debounce(fn, delay) {
    let timeoutId;  // Captured by closure
    
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), delay);
    };
}

const debouncedSearch = debounce(search, 300);
```

**Memoization:**
```javascript
function memoize(fn) {
    const cache = {};  // Captured by closure
    
    return function(arg) {
        if (arg in cache) {
            return cache[arg];
        }
        const result = fn(arg);
        cache[arg] = result;
        return result;
    };
}

const memoizedFib = memoize(fib);
```

## Practical Patterns

Common closure patterns in JavaScript.

**Currying:**
```javascript
function add(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}

add(1)(2)(3);  // 6

// Arrow function version
const addArrow = a => b => c => a + b + c;
```

**Configuration:**
```javascript
function createLogger(prefix) {
    return {
        log: (msg) => console.log(`[${prefix}] ${msg}`),
        error: (msg) => console.error(`[${prefix}] ERROR: ${msg}`)
    };
}

const appLogger = createLogger('App');
const dbLogger = createLogger('Database');

appLogger.log('Started');     // [App] Started
dbLogger.error('Connection failed');  // [Database] ERROR: Connection failed
```

**Iterators:**
```javascript
function createIterator(array) {
    let index = 0;
    
    return {
        next() {
            if (index < array.length) {
                return { value: array[index++], done: false };
            }
            return { done: true };
        }
    };
}

const iter = createIterator([1, 2, 3]);
iter.next();  // { value: 1, done: false }
iter.next();  // { value: 2, done: false }
```

## Memory Considerations

Closures and memory management.

**Memory Retention:**
```javascript
function createClosure() {
    const largeData = new Array(1000000);  // Large array
    
    return function() {
        return largeData.length;  // Keeps largeData in memory
    };
}

let closure = createClosure();
// largeData stays in memory as long as 'closure' exists
closure = null;  // Now largeData can be garbage collected
```

**Avoiding Memory Leaks:**
```javascript
// Potential leak: large data captured unnecessarily
function processData(data) {
    const processed = heavyProcessing(data);
    
    return function getResult() {
        return processed.summary;  // Only needs summary
    };
    // 'data' is also captured (large object in memory)
}

// Better: only capture what's needed
function processDataBetter(data) {
    const summary = heavyProcessing(data).summary;
    
    return function getResult() {
        return summary;  // Only summary is captured
    };
}
```

**Cleaning Up:**
```javascript
function createTimer() {
    let intervalId;
    
    return {
        start() {
            intervalId = setInterval(() => console.log('tick'), 1000);
        },
        stop() {
            clearInterval(intervalId);  // Important: clean up!
            intervalId = null;
        }
    };
}
```

## Summary / Key Takeaways

- **Closure:** Function that remembers variables from its lexical scope
- **Lexical environment:** Variables are captured from where function is defined
- **Live binding:** Closures share and maintain state across calls
- **Private variables:** Closures enable true data encapsulation
- **Common uses:** Factories, event handlers, debounce/throttle, memoization
- **Memory:** Captured variables persist; release references when done
- **Best practices:** Only capture needed variables; clean up timers/listeners
- **Power:** Closures enable functional programming patterns and modules

Closures are fundamental to JavaScript's functional nature and enable powerful programming patterns.
