# **[[3.8 Project: To-Do List Functions]]**

## Overview

This hands-on project applies function concepts to build a to-do list application. You'll implement CRUD operations, use modular function design, handle parameters properly, and return meaningful values.

## Project Goals

Build a functional to-do list that can:
- Add new tasks
- Mark tasks complete
- Delete tasks
- Filter and display tasks
- Use modular function design

## Project Setup

**Create Project Files:**
```
todo-functions/
â”œâ”€â”€ index.html
â”œâ”€â”€ todo.js
â””â”€â”€ README.md
```

**index.html:**
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>To-Do List Functions</title>
</head>
<body>
    <h1>To-Do List</h1>
    <p>Open console (F12) to use the to-do list</p>
    <script src="todo.js"></script>
</body>
</html>
```

## Building the To-Do List

**Version 1: Basic CRUD Functions**

```javascript
// todo.js

// Data storage
let todos = [];
let nextId = 1;

// CREATE: Add a new task
function addTodo(title, priority = "medium") {
    const todo = {
        id: nextId++,
        title: title,
        priority: priority,
        completed: false,
        createdAt: new Date()
    };
    
    todos.push(todo);
    console.log(`âœ… Added: "${title}"`);
    return todo;
}

// READ: Get all todos
function getAllTodos() {
    return [...todos];  // Return copy
}

// READ: Get todo by ID
function getTodoById(id) {
    return todos.find(todo => todo.id === id) || null;
}

// UPDATE: Toggle completion
function toggleComplete(id) {
    const todo = getTodoById(id);
    if (!todo) {
        console.error(`âŒ Todo #${id} not found`);
        return null;
    }
    
    todo.completed = !todo.completed;
    const status = todo.completed ? "completed" : "pending";
    console.log(`ðŸ“ "${todo.title}" marked as ${status}`);
    return todo;
}

// UPDATE: Edit title
function editTodo(id, newTitle) {
    const todo = getTodoById(id);
    if (!todo) {
        console.error(`âŒ Todo #${id} not found`);
        return null;
    }
    
    const oldTitle = todo.title;
    todo.title = newTitle;
    console.log(`âœï¸ Changed "${oldTitle}" to "${newTitle}"`);
    return todo;
}

// DELETE: Remove todo
function deleteTodo(id) {
    const index = todos.findIndex(todo => todo.id === id);
    if (index === -1) {
        console.error(`âŒ Todo #${id} not found`);
        return false;
    }
    
    const deleted = todos.splice(index, 1)[0];
    console.log(`ðŸ—‘ï¸ Deleted: "${deleted.title}"`);
    return true;
}

// Test basic operations
addTodo("Learn JavaScript");
addTodo("Build project", "high");
addTodo("Review code");
toggleComplete(1);
console.table(getAllTodos());
```

**Version 2: With Filtering and Display**

```javascript
// FILTER: Get todos by status
function getCompletedTodos() {
    return todos.filter(todo => todo.completed);
}

function getPendingTodos() {
    return todos.filter(todo => !todo.completed);
}

// FILTER: Get by priority
function getTodosByPriority(priority) {
    return todos.filter(todo => todo.priority === priority);
}

// DISPLAY: Pretty print todos
function displayTodos(todoList = todos, title = "All Todos") {
    console.log(`\nðŸ“‹ ${title}`);
    console.log("â”€".repeat(40));
    
    if (todoList.length === 0) {
        console.log("No todos found");
        return;
    }
    
    todoList.forEach(todo => {
        const status = todo.completed ? "âœ“" : "â—‹";
        const priority = {
            high: "ðŸ”´",
            medium: "ðŸŸ¡",
            low: "ðŸŸ¢"
        }[todo.priority];
        
        console.log(`${status} [${todo.id}] ${priority} ${todo.title}`);
    });
    
    console.log("â”€".repeat(40));
    console.log(`Total: ${todoList.length}`);
}

// STATS: Get statistics
function getStats() {
    const total = todos.length;
    const completed = getCompletedTodos().length;
    const pending = getPendingTodos().length;
    const highPriority = getTodosByPriority("high").length;
    
    return {
        total,
        completed,
        pending,
        highPriority,
        completionRate: total > 0 
            ? ((completed / total) * 100).toFixed(1) + "%" 
            : "0%"
    };
}

function displayStats() {
    const stats = getStats();
    console.log("\nðŸ“Š Statistics");
    console.log("â”€".repeat(30));
    console.table(stats);
}
```

**Version 3: Complete Application with Higher-Order Functions**

```javascript
// todo.js - Complete Version

const TodoApp = (function() {
    // Private state
    let todos = [];
    let nextId = 1;
    
    // Private helper functions
    function findTodo(id) {
        return todos.find(todo => todo.id === id);
    }
    
    function findIndex(id) {
        return todos.findIndex(todo => todo.id === id);
    }
    
    function validate(title) {
        if (!title || typeof title !== "string") {
            throw new Error("Title must be a non-empty string");
        }
        return title.trim();
    }
    
    // Public API
    return {
        // CREATE
        add(title, options = {}) {
            const cleanTitle = validate(title);
            
            const todo = {
                id: nextId++,
                title: cleanTitle,
                priority: options.priority || "medium",
                category: options.category || "general",
                completed: false,
                createdAt: new Date(),
                completedAt: null
            };
            
            todos.push(todo);
            return { ...todo };  // Return copy
        },
        
        // READ
        getAll() {
            return todos.map(todo => ({ ...todo }));
        },
        
        getById(id) {
            const todo = findTodo(id);
            return todo ? { ...todo } : null;
        },
        
        // UPDATE
        toggle(id) {
            const todo = findTodo(id);
            if (!todo) return null;
            
            todo.completed = !todo.completed;
            todo.completedAt = todo.completed ? new Date() : null;
            return { ...todo };
        },
        
        edit(id, updates) {
            const todo = findTodo(id);
            if (!todo) return null;
            
            if (updates.title) {
                todo.title = validate(updates.title);
            }
            if (updates.priority) {
                todo.priority = updates.priority;
            }
            if (updates.category) {
                todo.category = updates.category;
            }
            
            return { ...todo };
        },
        
        // DELETE
        remove(id) {
            const index = findIndex(id);
            if (index === -1) return false;
            
            todos.splice(index, 1);
            return true;
        },
        
        clear(completed = true) {
            if (completed) {
                todos = todos.filter(todo => !todo.completed);
            } else {
                todos = [];
            }
        },
        
        // FILTER (Higher-order function usage)
        filter(predicate) {
            return todos.filter(predicate).map(todo => ({ ...todo }));
        },
        
        getCompleted() {
            return this.filter(todo => todo.completed);
        },
        
        getPending() {
            return this.filter(todo => !todo.completed);
        },
        
        getByPriority(priority) {
            return this.filter(todo => todo.priority === priority);
        },
        
        getByCategory(category) {
            return this.filter(todo => todo.category === category);
        },
        
        search(query) {
            const lowerQuery = query.toLowerCase();
            return this.filter(todo => 
                todo.title.toLowerCase().includes(lowerQuery)
            );
        },
        
        // TRANSFORM
        map(transformer) {
            return todos.map(transformer);
        },
        
        // AGGREGATE
        reduce(reducer, initial) {
            return todos.reduce(reducer, initial);
        },
        
        // STATS
        getStats() {
            return {
                total: todos.length,
                completed: this.getCompleted().length,
                pending: this.getPending().length,
                byPriority: {
                    high: this.getByPriority("high").length,
                    medium: this.getByPriority("medium").length,
                    low: this.getByPriority("low").length
                }
            };
        },
        
        // DISPLAY
        display(list = todos, title = "Todos") {
            console.log(`\nðŸ“‹ ${title}`);
            console.log("â•".repeat(50));
            
            if (list.length === 0) {
                console.log("(empty)");
                return;
            }
            
            const icons = { high: "ðŸ”´", medium: "ðŸŸ¡", low: "ðŸŸ¢" };
            
            list.forEach(todo => {
                const check = todo.completed ? "âœ“" : "â—‹";
                const icon = icons[todo.priority];
                console.log(`${check} [${todo.id}] ${icon} ${todo.title}`);
            });
            
            console.log("â•".repeat(50));
        }
    };
})();

// Interactive demo
console.log("ðŸš€ Todo App Ready!");
console.log("Use TodoApp.add(), .toggle(), .remove(), etc.");
```

## Concepts Applied

**1. Function Modularity:**
```javascript
// Each function has single responsibility
function addTodo(title) { /* add logic */ }
function getTodoById(id) { /* find logic */ }
function deleteTodo(id) { /* delete logic */ }
```

**2. Parameters & Defaults:**
```javascript
function addTodo(title, priority = "medium") {
    // priority defaults to "medium" if not provided
}

function display(list = todos, title = "Todos") {
    // Both parameters have defaults
}
```

**3. Return Values:**
```javascript
// Return the created/updated object
function addTodo(title) {
    const todo = { ... };
    todos.push(todo);
    return todo;  // Useful for chaining
}

// Return boolean for success/failure
function deleteTodo(id) {
    // ...
    return true;  // or false
}
```

**4. Higher-Order Functions:**
```javascript
// Using filter
function getCompletedTodos() {
    return todos.filter(todo => todo.completed);
}

// Custom predicate parameter
function filter(predicate) {
    return todos.filter(predicate);
}

// Using map for transformation
function getTitles() {
    return todos.map(todo => todo.title);
}
```

**5. Closures (Module Pattern):**
```javascript
const TodoApp = (function() {
    // Private state
    let todos = [];
    
    // Public API
    return {
        add() { /* can access todos */ },
        getAll() { /* can access todos */ }
    };
})();
```

## Extension Challenges

**1. Add Due Dates:**
```javascript
function addTodo(title, { priority, dueDate } = {}) {
    return {
        // ...
        dueDate: dueDate ? new Date(dueDate) : null
    };
}

function getOverdue() {
    const now = new Date();
    return todos.filter(todo => 
        !todo.completed && todo.dueDate && todo.dueDate < now
    );
}
```

**2. Add Tags:**
```javascript
function addTag(id, tag) {
    const todo = getTodoById(id);
    if (!todo.tags) todo.tags = [];
    todo.tags.push(tag);
}

function getByTag(tag) {
    return todos.filter(todo => 
        todo.tags && todo.tags.includes(tag)
    );
}
```

**3. Undo Functionality:**
```javascript
let history = [];

function execute(action, ...args) {
    const before = JSON.stringify(todos);
    const result = action(...args);
    history.push(before);
    return result;
}

function undo() {
    if (history.length === 0) return false;
    todos = JSON.parse(history.pop());
    return true;
}
```

## Summary / Key Takeaways

- **CRUD functions:** Separate functions for Create, Read, Update, Delete
- **Single responsibility:** Each function does one thing well
- **Return values:** Return created/updated objects or success boolean
- **Default parameters:** Provide sensible defaults for optional arguments
- **Higher-order functions:** Use filter, map, reduce for data operations
- **Closures:** Module pattern for encapsulation and private state
- **Immutability:** Return copies to prevent external mutation
- **Clean API:** Consistent naming, clear parameters, predictable returns

This project demonstrates how functions enable modular, maintainable, and testable code organization.
